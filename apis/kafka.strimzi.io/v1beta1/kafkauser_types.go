// Code generated by schema-generate. DO NOT EDIT.

package v1beta1

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"reflect"
)

func ValueTypeToString(valueType jsoniter.ValueType) string {
	switch valueType {
	case jsoniter.StringValue:
		return "string"
	case jsoniter.NumberValue:
		return "number"
	case jsoniter.NilValue:
		return "nil"
	case jsoniter.BoolValue:
		return "bool"
	case jsoniter.ArrayValue:
		return "array"
	case jsoniter.ObjectValue:
		return "object"
	default:
		return "invalid"
	}
}

type commaTracker struct {
	stream *jsoniter.Stream
	started bool
}

func (t *commaTracker) More() {
	if t.started {
		t.stream.WriteMore()
	} else {
		t.started = true
	}
}

type isEmptyChecker interface {
	IsEmpty() bool
}

// IsEmpty reports whether v is zero struct
// Does not support cycle pointers for performance, so as json
func IsEmpty(v interface{}) bool {
	if i, ok := v.(isEmptyChecker); ok {
		return i.IsEmpty()
	}
	rv := reflect.ValueOf(v)
	return !rv.IsValid() || rv.IsZero()
}

var (
	jsonNullValue = []byte("null")
)

// NewEmptyBool creates a non-empty EmptyBool
func NewEmptyBool(value bool) EmptyBool {
	return EmptyBool{value, true}
}

// EmptyBool is bool or nothing
type EmptyBool struct {
	Bool bool
	Valid bool // Valid is true if Bool is not empty
}

func (t EmptyBool) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyBool) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Bool)
	}
	return []byte("\"\""), nil
}

func (t *EmptyBool) Set(value bool) {
	t.Bool = value
	t.Valid = true
}

func (t *EmptyBool) Unset() {
	t.Bool = false
	t.Valid = false
}

func (t EmptyBool) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteBool(t.Bool)
	} else {
		stream.WriteBool(false)
	}
}

func (t *EmptyBool) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Bool = iter.ReadBool()
	t.Valid = iter.Error == nil
}

func (t *EmptyBool) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Bool); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyFloat64 creates a non-empty EmptyFloat64
func NewEmptyFloat64(value float64) EmptyFloat64 {
	return EmptyFloat64{value, true}
}

// EmptyFloat64 is float64 or nothing
type EmptyFloat64 struct {
	Float64 float64
	Valid bool // Valid is true if Float64 is not empty
}

func (t EmptyFloat64) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyFloat64) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Float64)
	}
	return []byte("\"\""), nil
}

func (t *EmptyFloat64) Set(value float64) {
	t.Float64 = value
	t.Valid = true
}

func (t *EmptyFloat64) Unset() {
	t.Float64 = 0.0
	t.Valid = false
}

func (t EmptyFloat64) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteFloat64(t.Float64)
	} else {
		stream.WriteFloat64(0.0)
	}
}

func (t *EmptyFloat64) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Float64 = iter.ReadFloat64()
	t.Valid = iter.Error == nil
}

func (t *EmptyFloat64) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Float64); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyInt creates a non-empty EmptyInt
func NewEmptyInt(value int) EmptyInt {
	return EmptyInt{value, true}
}

// EmptyInt is int or nothing
type EmptyInt struct {
	Int int
	Valid bool // Valid is true if Int is not empty
}

func (t EmptyInt) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyInt) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Int)
	}
	return []byte("\"\""), nil
}

func (t *EmptyInt) Set(value int) {
	t.Int = value
	t.Valid = true
}

func (t *EmptyInt) Unset() {
	t.Int = 0
	t.Valid = false
}

func (t EmptyInt) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteInt(t.Int)
	} else {
		stream.WriteInt(0)
	}
}

func (t *EmptyInt) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Int = iter.ReadInt()
	t.Valid = iter.Error == nil
}

func (t *EmptyInt) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Int); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyString creates a non-empty EmptyString
func NewEmptyString(value string) EmptyString {
	return EmptyString{value, true}
}

// EmptyString is string or nothing
type EmptyString struct {
	String string
	Valid bool // Valid is true if String is not empty
}

func (t EmptyString) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyString) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.String)
	}
	return []byte("\"\""), nil
}

func (t *EmptyString) Set(value string) {
	t.String = value
	t.Valid = true
}

func (t *EmptyString) Unset() {
	t.String = ""
	t.Valid = false
}

func (t EmptyString) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteString(t.String)
	} else {
		stream.WriteString("")
	}
}

func (t *EmptyString) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.String = iter.ReadString()
	t.Valid = iter.Error == nil
}

func (t *EmptyString) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.String); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// OneOfStringNull is a 'string' or a 'null', and can be emptied
type OneOfStringNull struct {
	currentType jsoniter.ValueType
	stringValue string
}

// NewOneOfStringNull creates a empty OneOfStringNull
func NewOneOfStringNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.InvalidValue, ""}
}

// NewOneOfStringNullString creates a OneOfStringNull of type string
func NewOneOfStringNullString(value string) OneOfStringNull {
	return OneOfStringNull{jsoniter.StringValue, value}
}

// NewOneOfStringNullNull creates a OneOfStringNull of type null
func NewOneOfStringNullNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.NilValue, ""}
}

// IsEmpty returns true if the value is empty
func (value *OneOfStringNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfStringNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsString returns true if the value is a string
func (value *OneOfStringNull) IsString() bool {
	return value.currentType == jsoniter.StringValue
}

// StringValue returns the current value if IsString() is true, "" otherwise
func (value *OneOfStringNull) StringValue() string {
	if value.currentType == jsoniter.StringValue {
		return value.stringValue
	}
	return ""
}

// NullString returns the current value as a sql.NullString
func (value *OneOfStringNull) NullString() sql.NullString {
	return sql.NullString{
		Valid:  value.currentType == jsoniter.StringValue,
		String: value.stringValue,
	}
}

// MarshalJSONStream serializes to a jsoniter Stream
func (value OneOfStringNull) MarshalJSONStream(stream *jsoniter.Stream) {
	if value.currentType == jsoniter.StringValue {
		stream.WriteString(value.stringValue)
	} else {
		stream.WriteNil()
	}
}

// MarshalJSON serialize to json
func (value OneOfStringNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.StringValue:
		return jsoniter.Marshal(value.stringValue)
	}
	return nil, fmt.Errorf(
		"OneOfStringNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

func (value *OneOfStringNull) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	switch t := iter.WhatIsNext(); t {
	case jsoniter.NilValue:
		iter.ReadNil()
		value.currentType = jsoniter.NilValue
	case jsoniter.StringValue:
		value.currentType = jsoniter.StringValue
		value.stringValue = iter.ReadString()
	default:
		iter.ReportError("Read", fmt.Sprintf("unexpected value type: %v", t))
	}
}

// UnmarshalJSON unserialize a OneOfStringNull from json
func (value *OneOfStringNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.stringValue); err != nil {
			return err
		}
		value.currentType = jsoniter.StringValue
	}
	return nil
}

// OneOfNumberNull is a 'string' or a 'null', and can be emptied
type OneOfNumberNull struct {
	currentType jsoniter.ValueType
	numberValue float64
}

// NewOneOfNumberNull creates a empty OneOfNumberNull
func NewOneOfNumberNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.InvalidValue, 0}
}

// NewOneOfNumberNullNumber creates a OneOfNumberNull of type number
func NewOneOfNumberNullNumber(value float64) OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NumberValue, value}
}

// NewOneOfNumberNullNull creates a OneOfNumberNull of type null
func NewOneOfNumberNullNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NilValue, 0}
}

// IsEmpty returns true if the value is empty
func (value *OneOfNumberNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfNumberNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsNumber returns true if the value is a number
func (value *OneOfNumberNull) IsNumber() bool {
	return value.currentType == jsoniter.NumberValue
}

// NumberValue returns the current value if IsNumber() is true, 0 otherwise
func (value *OneOfNumberNull) NumberValue() float64 {
	if value.currentType == jsoniter.NumberValue {
		return value.numberValue
	}
	return 0
}

// MarshalJSON serialize to json
func (value OneOfNumberNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.NumberValue:
		return jsoniter.Marshal(value.numberValue)
	}
	return nil, fmt.Errorf(
		"OneOfNumberNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfNumberNull from json
func (value *OneOfNumberNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.numberValue); err != nil {
			return err
		}
		value.currentType = jsoniter.NumberValue
	}
	return nil
}

// OneOfBoolNull is a 'bool' or a 'null', and can be emptied
type OneOfBoolNull struct {
	currentType jsoniter.ValueType
	boolValue   bool
}

// NewOneOfBoolNull creates a empty OneOfBoolNull
func NewOneOfBoolNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.InvalidValue, false}
}

// NewOneOfBoolNullBool creates a OneOfBoolNull of type number
func NewOneOfBoolNullBool(value bool) OneOfBoolNull {
	return OneOfBoolNull{jsoniter.BoolValue, value}
}

// NewOneOfBoolNullNull creates a OneOfBoolNull of type null
func NewOneOfBoolNullNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.NilValue, false}
}

// IsEmpty returns true if the value is empty
func (value *OneOfBoolNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfBoolNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsBool returns true if the value is a bool
func (value *OneOfBoolNull) IsBool() bool {
	return value.currentType == jsoniter.BoolValue
}

// BoolValue returns the current value if IsBool() is true, false otherwise
func (value *OneOfBoolNull) BoolValue() bool {
	if value.currentType == jsoniter.BoolValue {
		return value.boolValue
	}
	return false
}

// MarshalJSON serialize to json
func (value OneOfBoolNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.BoolValue:
		return jsoniter.Marshal(value.boolValue)
	}
	return nil, fmt.Errorf(
		"OneOfBoolNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfBoolNull from json
func (value *OneOfBoolNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.boolValue); err != nil {
			return err
		}
		value.currentType = jsoniter.BoolValue
	}
	return nil
}

// AclsItems 
type AclsItems struct {
	// Host The host from which the action described in the ACL rule is allowed or denied.
	Host string `json:"host,omitempty"`

	// Operation Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
	Operation string `json:"operation"`

	// Resource Indicates the resource for which given ACL rule applies.
	Resource *Resource `json:"resource"`

	// Type The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
	Type string `json:"type,omitempty"`

}

// Annotations Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
type Annotations struct {
}

// Authentication Authentication mechanism enabled for this Kafka user.
type Authentication struct {
	// Type Authentication type.
	Type string `json:"type"`

}

// Authorization Authorization rules for this Kafka user.
type Authorization struct {
	// Acls List of ACL rules which should be applied to this user.
	Acls []*AclsItems `json:"acls"`

	// Type Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
	Type string `json:"type"`

}

// ConditionsItems 
type ConditionsItems struct {
	// LastTransitionTime Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime string `json:"lastTransitionTime,omitempty"`

	// Message Human-readable message indicating details about the condition's last transition.
	Message string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition (a single word in CamelCase).
	Reason string `json:"reason,omitempty"`

	// Status The status of the condition, either True, False or Unknown.
	Status string `json:"status,omitempty"`

	// Type The unique identifier of a condition, used to distinguish between other conditions in the resource.
	Type string `json:"type,omitempty"`

}

// KafkaUser 
type KafkaUser struct {
	// Spec The specification of the user.
	Spec *Spec `json:"spec,omitempty"`

	// Status The status of the Kafka User.
	Status *Status `json:"status,omitempty"`

}

// Labels Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
type Labels struct {
}

// Metadata Metadata applied to the resource.
type Metadata struct {
	// Annotations Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Labels Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *Labels `json:"labels,omitempty"`

}

// Quotas Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
type Quotas struct {
	// ConsumerByteRate A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
	ConsumerByteRate int `json:"consumerByteRate,omitempty"`

	// ProducerByteRate A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
	ProducerByteRate int `json:"producerByteRate,omitempty"`

	// RequestPercentage A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
	RequestPercentage int `json:"requestPercentage,omitempty"`

}

// Resource Indicates the resource for which given ACL rule applies.
type Resource struct {
	// Name Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
	Name string `json:"name,omitempty"`

	// PatternType Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
	PatternType string `json:"patternType,omitempty"`

	// Type Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
	Type string `json:"type"`

}

// Secret Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
type Secret struct {
	// Metadata Metadata applied to the resource.
	Metadata *Metadata `json:"metadata,omitempty"`

}

// Spec The specification of the user.
type Spec struct {
	// Authentication Authentication mechanism enabled for this Kafka user.
	Authentication *Authentication `json:"authentication,omitempty"`

	// Authorization Authorization rules for this Kafka user.
	Authorization *Authorization `json:"authorization,omitempty"`

	// Quotas Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
	Quotas *Quotas `json:"quotas,omitempty"`

	// Template Template to specify how Kafka User `Secrets` are generated.
	Template *Template `json:"template,omitempty"`

}

// Status The status of the Kafka User.
type Status struct {
	// Conditions List of status conditions.
	Conditions []*ConditionsItems `json:"conditions,omitempty"`

	// ObservedGeneration The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration int `json:"observedGeneration,omitempty"`

	// Secret The name of `Secret` where the credentials are stored.
	Secret string `json:"secret,omitempty"`

	// Username Username.
	Username string `json:"username,omitempty"`

}

// Template Template to specify how Kafka User `Secrets` are generated.
type Template struct {
	// Secret Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
	Secret *Secret `json:"secret,omitempty"`

}


// MarshalJSON serializes to JSON
func (s *AclsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s AclsItems) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Host field
	if !IsEmpty(s.Host) {
	ct.More()
	stream.WriteObjectField("host")
	stream.WriteString(s.Host)
	}

	// Marshal the Operation field
	ct.More()
	stream.WriteObjectField("operation")
	stream.WriteString(s.Operation)

	// Marshal the Resource field

	// Resource is required
	if s.Resource == nil {
		stream.Error = errors.New("Resource (resource) is a required")
		return
	}
	ct.More()
	stream.WriteObjectField("resource")
	stream.WriteVal(s.Resource)
	if stream.Error != nil {
		return
	}

	// Marshal the Type field
	if !IsEmpty(s.Type) {
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	}
	stream.WriteObjectEnd()
}

func (s *AclsItems) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *AclsItems) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	OperationReceived := false
	ResourceReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "host":
			s.Host = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "operation":
			s.Operation = iter.ReadString()
			if iter.Error != nil {
				return
			}
			OperationReceived = true
		case "resource":
			iter.ReadVal(&s.Resource)
			if iter.Error != nil {
				return
			}
			ResourceReceived = true
		case "type":
			s.Type = iter.ReadString()
			if iter.Error != nil {
				return
			}
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !OperationReceived {
		iter.ReportError("validating AclsItems", "\"operation\" is required but was not present")
	}

	if !ResourceReceived {
		iter.ReportError("validating AclsItems", "\"resource\" is required but was not present")
	}
}



// MarshalJSON serializes to JSON
func (s *Authentication) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Authentication) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Type field
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	stream.WriteObjectEnd()
}

func (s *Authentication) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Authentication) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	TypeReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "type":
			s.Type = iter.ReadString()
			if iter.Error != nil {
				return
			}
			TypeReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !TypeReceived {
		iter.ReportError("validating Authentication", "\"type\" is required but was not present")
	}
}


// MarshalJSON serializes to JSON
func (s *Authorization) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Authorization) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Acls field
	ct.More()
	stream.WriteObjectField("acls")
	stream.WriteVal(s.Acls)
	if stream.Error != nil {
		return
	}

	// Marshal the Type field
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	stream.WriteObjectEnd()
}

func (s *Authorization) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Authorization) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	AclsReceived := false
	TypeReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "acls":
			iter.ReadVal(&s.Acls)
			if iter.Error != nil {
				return
			}
			AclsReceived = true
		case "type":
			s.Type = iter.ReadString()
			if s.Type != "simple" {
				iter.ReportError(
					"type",
					fmt.Sprintf("Expected %s, got \"%s\"", "simple", s.Type),
				)
			}
			if iter.Error != nil {
				return
			}
			TypeReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !AclsReceived {
		iter.ReportError("validating Authorization", "\"acls\" is required but was not present")
	}

	if !TypeReceived {
		iter.ReportError("validating Authorization", "\"type\" is required but was not present")
	}
}







// MarshalJSON serializes to JSON
func (s *Resource) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s Resource) MarshalJSONStream(stream *jsoniter.Stream) {
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	// Marshal the Name field
	if !IsEmpty(s.Name) {
	ct.More()
	stream.WriteObjectField("name")
	stream.WriteString(s.Name)
	}

	// Marshal the PatternType field
	if !IsEmpty(s.PatternType) {
	ct.More()
	stream.WriteObjectField("patternType")
	stream.WriteString(s.PatternType)
	}

	// Marshal the Type field
	ct.More()
	stream.WriteObjectField("type")
	stream.WriteString(s.Type)
	stream.WriteObjectEnd()
}

func (s *Resource) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *Resource) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	TypeReceived := false

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		case "name":
			s.Name = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "patternType":
			s.PatternType = iter.ReadString()
			if iter.Error != nil {
				return
			}
		case "type":
			s.Type = iter.ReadString()
			if iter.Error != nil {
				return
			}
			TypeReceived = true
		default:
			// Ignore the additional property
			iter.Skip()
		}
	}

	if !TypeReceived {
		iter.ReportError("validating Resource", "\"type\" is required but was not present")
	}
}



