// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1beta2

import "fmt"
import "reflect"
import "encoding/json"

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
import apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemType, v)
	}
	*j = KafkaSpecKafkaListenersElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kafka"]; !ok || v == nil {
		return fmt.Errorf("field kafka: required")
	}
	if v, ok := raw["zookeeper"]; !ok || v == nil {
		return fmt.Errorf("field zookeeper: required")
	}
	type Plain KafkaSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecClientsCaCertificateExpirationPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecClientsCaCertificateExpirationPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecClientsCaCertificateExpirationPolicy, v)
	}
	*j = KafkaSpecClientsCaCertificateExpirationPolicy(v)
	return nil
}

const KafkaSpecClientsCaCertificateExpirationPolicyRenewCertificate KafkaSpecClientsCaCertificateExpirationPolicy = "renew-certificate"
const KafkaSpecClientsCaCertificateExpirationPolicyReplaceKey KafkaSpecClientsCaCertificateExpirationPolicy = "replace-key"

// Configuration of the clients certificate authority.
type KafkaSpecClientsCa struct {
	// How should CA certificate expiration be handled when
	// `generateCertificateAuthority=true`. The default is for a new CA certificate to
	// be generated reusing the existing private key.
	CertificateExpirationPolicy *KafkaSpecClientsCaCertificateExpirationPolicy `json:"certificateExpirationPolicy,omitempty"`

	// If true then Certificate Authority certificates will be generated
	// automatically. Otherwise the user will need to provide a Secret with the CA
	// certificate. Default is true.
	GenerateCertificateAuthority *bool `json:"generateCertificateAuthority,omitempty"`

	// If `true`, the Cluster and Client CA Secrets are configured with the
	// `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is
	// deleted when `true`, the CA Secrets are also deleted. If `false`, the
	// `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`,
	// the CA Secrets are retained and available for reuse. Default is `true`.
	GenerateSecretOwnerReference *bool `json:"generateSecretOwnerReference,omitempty"`

	// The number of days in the certificate renewal period. This is the number of
	// days before the a certificate expires during which renewal actions may be
	// performed. When `generateCertificateAuthority` is true, this will cause the
	// generation of a new certificate. When `generateCertificateAuthority` is true,
	// this will cause extra logging at WARN level about the pending certificate
	// expiry. Default is 30.
	RenewalDays *int32 `json:"renewalDays,omitempty"`

	// The number of days generated certificates should be valid for. The default is
	// 365.
	ValidityDays *int32 `json:"validityDays,omitempty"`
}

type KafkaSpecClusterCaCertificateExpirationPolicy string

// The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
type KafkaSpec struct {
	// Configuration of the clients certificate authority.
	ClientsCa *KafkaSpecClientsCa `json:"clientsCa,omitempty"`

	// Configuration of the cluster certificate authority.
	ClusterCa *KafkaSpecClusterCa `json:"clusterCa,omitempty"`

	// Configuration for Cruise Control deployment. Deploys a Cruise Control instance
	// when specified.
	CruiseControl *KafkaSpecCruiseControl `json:"cruiseControl,omitempty"`

	// Configuration of the Entity Operator.
	EntityOperator *KafkaSpecEntityOperator `json:"entityOperator,omitempty"`

	// Configuration for JmxTrans. When the property is present a JmxTrans deployment
	// is created for gathering JMX metrics from each Kafka broker. For more
	// information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
	JmxTrans *KafkaSpecJmxTrans `json:"jmxTrans,omitempty"`

	// Configuration of the Kafka cluster.
	Kafka KafkaSpecKafka `json:"kafka"`

	// Configuration of the Kafka Exporter. Kafka Exporter can provide additional
	// metrics, for example lag of consumer group at topic/partition.
	KafkaExporter *KafkaSpecKafkaExporter `json:"kafkaExporter,omitempty"`

	// A list of time windows for maintenance tasks (that is, certificates renewal).
	// Each time window is defined by a cron expression.
	MaintenanceTimeWindows []string `json:"maintenanceTimeWindows,omitempty"`

	// Configuration of the ZooKeeper cluster.
	Zookeeper KafkaSpecZookeeper `json:"zookeeper"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecClusterCaCertificateExpirationPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecClusterCaCertificateExpirationPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecClusterCaCertificateExpirationPolicy, v)
	}
	*j = KafkaSpecClusterCaCertificateExpirationPolicy(v)
	return nil
}

const KafkaSpecClusterCaCertificateExpirationPolicyRenewCertificate KafkaSpecClusterCaCertificateExpirationPolicy = "renew-certificate"
const KafkaSpecClusterCaCertificateExpirationPolicyReplaceKey KafkaSpecClusterCaCertificateExpirationPolicy = "replace-key"

// Configuration of the cluster certificate authority.
type KafkaSpecClusterCa struct {
	// How should CA certificate expiration be handled when
	// `generateCertificateAuthority=true`. The default is for a new CA certificate to
	// be generated reusing the existing private key.
	CertificateExpirationPolicy *KafkaSpecClusterCaCertificateExpirationPolicy `json:"certificateExpirationPolicy,omitempty"`

	// If true then Certificate Authority certificates will be generated
	// automatically. Otherwise the user will need to provide a Secret with the CA
	// certificate. Default is true.
	GenerateCertificateAuthority *bool `json:"generateCertificateAuthority,omitempty"`

	// If `true`, the Cluster and Client CA Secrets are configured with the
	// `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is
	// deleted when `true`, the CA Secrets are also deleted. If `false`, the
	// `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`,
	// the CA Secrets are retained and available for reuse. Default is `true`.
	GenerateSecretOwnerReference *bool `json:"generateSecretOwnerReference,omitempty"`

	// The number of days in the certificate renewal period. This is the number of
	// days before the a certificate expires during which renewal actions may be
	// performed. When `generateCertificateAuthority` is true, this will cause the
	// generation of a new certificate. When `generateCertificateAuthority` is true,
	// this will cause extra logging at WARN level about the pending certificate
	// expiry. Default is 30.
	RenewalDays *int32 `json:"renewalDays,omitempty"`

	// The number of days generated certificates should be valid for. The default is
	// 365.
	ValidityDays *int32 `json:"validityDays,omitempty"`
}

// The Cruise Control `brokerCapacity` configuration.
type KafkaSpecCruiseControlBrokerCapacity struct {
	// Broker capacity for CPU resource utilization as a percentage (0 - 100).
	CpuUtilization *int32 `json:"cpuUtilization,omitempty"`

	// Broker capacity for disk in bytes, for example, 100Gi.
	Disk *string `json:"disk,omitempty"`

	// Broker capacity for inbound network throughput in bytes per second, for
	// example, 10000KB/s.
	InboundNetwork *string `json:"inboundNetwork,omitempty"`

	// Broker capacity for outbound network throughput in bytes per second, for
	// example 10000KB/s.
	OutboundNetwork *string `json:"outboundNetwork,omitempty"`
}

// The Cruise Control configuration. For a full list of configuration options refer
// to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that
// properties with the following prefixes cannot be set: bootstrap.servers,
// client.id, zookeeper., network., security.,
// failed.brokers.zk.path,webserver.http., webserver.api.urlprefix,
// webserver.session.path, webserver.accesslog., two.step.,
// request.reason.required,metric.reporter.sampler.bootstrap.servers,
// metric.reporter.topic, partition.metric.sample.store.topic,
// broker.metric.sample.store.topic,capacity.config.file, self.healing., ssl. (with
// the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,
// webserver.http.cors.enabled, webserver.http.cors.origin,
// webserver.http.cors.exposeheaders, webserver.security.enable,
// webserver.ssl.enable).
//type KafkaSpecCruiseControlConfig map[string]interface{}

// A map of -XX options to the JVM.
//type KafkaSpecCruiseControlJvmOptionsXX map[string]interface{}

type KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// JVM Options for the Cruise Control container.
type KafkaSpecCruiseControlJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

// Pod liveness checking for the Cruise Control container.
type KafkaSpecCruiseControlLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaSpecCruiseControlLoggingLoggers map[string]interface{}

type KafkaSpecCruiseControlLoggingType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeper) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["replicas"]; !ok || v == nil {
		return fmt.Errorf("field replicas: required")
	}
	if v, ok := raw["storage"]; !ok || v == nil {
		return fmt.Errorf("field storage: required")
	}
	type Plain KafkaSpecZookeeper
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecZookeeper(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecCruiseControlLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecCruiseControlLoggingType, v)
	}
	*j = KafkaSpecCruiseControlLoggingType(v)
	return nil
}

const KafkaSpecCruiseControlLoggingTypeInline KafkaSpecCruiseControlLoggingType = "inline"
const KafkaSpecCruiseControlLoggingTypeExternal KafkaSpecCruiseControlLoggingType = "external"

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// `ConfigMap` entry where the logging configuration is stored.
type KafkaSpecCruiseControlLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Logging configuration (Log4j 2) for Cruise Control.
type KafkaSpecCruiseControlLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaSpecCruiseControlLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaSpecCruiseControlLoggingValueFrom `json:"valueFrom,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecCruiseControlLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecCruiseControlLogging(plain)
	return nil
}

type KafkaSpecCruiseControlMetricsConfigType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy, v)
	}
	*j = KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlMetricsConfigType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecCruiseControlMetricsConfigType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecCruiseControlMetricsConfigType, v)
	}
	*j = KafkaSpecCruiseControlMetricsConfigType(v)
	return nil
}

const KafkaSpecCruiseControlMetricsConfigTypeJmxPrometheusExporter KafkaSpecCruiseControlMetricsConfigType = "jmxPrometheusExporter"

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
// details of the structure of this configuration, see the {JMXExporter}.
type KafkaSpecCruiseControlMetricsConfigValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Metrics configuration.
type KafkaSpecCruiseControlMetricsConfig struct {
	// Metrics type. Only 'jmxPrometheusExporter' supported currently.
	Type KafkaSpecCruiseControlMetricsConfigType `json:"type"`

	// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
	// details of the structure of this configuration, see the {JMXExporter}.
	ValueFrom KafkaSpecCruiseControlMetricsConfigValueFrom `json:"valueFrom"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlMetricsConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom: required")
	}
	type Plain KafkaSpecCruiseControlMetricsConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecCruiseControlMetricsConfig(plain)
	return nil
}

// Pod readiness checking for the Cruise Control container.
type KafkaSpecCruiseControlReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

//type KafkaSpecCruiseControlResourcesLimits map[string]interface{}

//type KafkaSpecCruiseControlResourcesRequests map[string]interface{}

// CPU and memory resources to reserve for the Cruise Control container.
type KafkaSpecCruiseControlResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

type KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy, v)
	}
	*j = KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem, v)
	}
	*j = KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem(v)
	return nil
}

const KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElemIPv4 KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem = "IPv4"
const KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElemIPv6 KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem = "IPv6"

type KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem, v)
	}
	*j = KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy, v)
	}
	*j = KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy(v)
	return nil
}

const KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicySingleStack KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy = "SingleStack"
const KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicyPreferDualStack KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy = "PreferDualStack"
const KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicyRequireDualStack KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy = "RequireDualStack"

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateApiServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateApiServiceMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecCruiseControlTemplateApiServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for Cruise Control API `Service`.
type KafkaSpecCruiseControlTemplateApiService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecCruiseControlTemplateApiServiceMetadata `json:"metadata,omitempty"`
}

type KafkaSpecCruiseControlTemplateCruiseControlContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for the Cruise Control container.
type KafkaSpecCruiseControlTemplateCruiseControlContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecCruiseControlTemplateCruiseControlContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext `json:"securityContext,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateDeploymentMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateDeploymentMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecCruiseControlTemplateDeploymentMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for Cruise Control `Deployment`.
type KafkaSpecCruiseControlTemplateDeployment struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecCruiseControlTemplateDeploymentMetadata `json:"metadata,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// The pod's affinity rules.
type KafkaSpecCruiseControlTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecCruiseControlTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplatePodMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecCruiseControlTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecClientsCaCertificateExpirationPolicy string

// Configures pod-level security attributes and common container settings.
type KafkaSpecCruiseControlTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

// Template for Cruise Control `Pods`.
type KafkaSpecCruiseControlTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecCruiseControlTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecCruiseControlTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecCruiseControlTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecCruiseControlTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecCruiseControlTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecCruiseControlTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataLabels map[string]interface{}

// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
type KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for Cruise Control `PodDisruptionBudget`.
type KafkaSpecCruiseControlTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
	Metadata *KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecCruiseControlTemplateServiceAccountMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecCruiseControlTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for the Cruise Control service account.
type KafkaSpecCruiseControlTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecCruiseControlTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

type KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for the Cruise Control TLS sidecar container.
type KafkaSpecCruiseControlTemplateTlsSidecarContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext `json:"securityContext,omitempty"`
}

// Template to specify how Cruise Control resources, `Deployments` and `Pods`, are
// generated.
type KafkaSpecCruiseControlTemplate struct {
	// Template for Cruise Control API `Service`.
	ApiService *KafkaSpecCruiseControlTemplateApiService `json:"apiService,omitempty"`

	// Template for the Cruise Control container.
	CruiseControlContainer *KafkaSpecCruiseControlTemplateCruiseControlContainer `json:"cruiseControlContainer,omitempty"`

	// Template for Cruise Control `Deployment`.
	Deployment *KafkaSpecCruiseControlTemplateDeployment `json:"deployment,omitempty"`

	// Template for Cruise Control `Pods`.
	Pod *KafkaSpecCruiseControlTemplatePod `json:"pod,omitempty"`

	// Template for Cruise Control `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaSpecCruiseControlTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty"`

	// Template for the Cruise Control service account.
	ServiceAccount *KafkaSpecCruiseControlTemplateServiceAccount `json:"serviceAccount,omitempty"`

	// Template for the Cruise Control TLS sidecar container.
	TlsSidecarContainer *KafkaSpecCruiseControlTemplateTlsSidecarContainer `json:"tlsSidecarContainer,omitempty"`
}

// Pod liveness checking.
type KafkaSpecCruiseControlTlsSidecarLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

type KafkaSpecCruiseControlTlsSidecarLogLevel string

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type Kafka struct {

	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
	Spec *KafkaSpec `json:"spec,omitempty"`

	// The status of the Kafka and ZooKeeper clusters, and Topic Operator.
	Status *KafkaStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaList contains a list of instances.
type KafkaList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of Kafka objects.
	Items []Kafka `json:"items,omitempty"`
}

func init() {
	SchemeBuilder.Register(&Kafka{}, &KafkaList{})
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecCruiseControlTlsSidecarLogLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecCruiseControlTlsSidecarLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecCruiseControlTlsSidecarLogLevel, v)
	}
	*j = KafkaSpecCruiseControlTlsSidecarLogLevel(v)
	return nil
}

const KafkaSpecCruiseControlTlsSidecarLogLevelEmerg KafkaSpecCruiseControlTlsSidecarLogLevel = "emerg"
const KafkaSpecCruiseControlTlsSidecarLogLevelAlert KafkaSpecCruiseControlTlsSidecarLogLevel = "alert"
const KafkaSpecCruiseControlTlsSidecarLogLevelCrit KafkaSpecCruiseControlTlsSidecarLogLevel = "crit"
const KafkaSpecCruiseControlTlsSidecarLogLevelErr KafkaSpecCruiseControlTlsSidecarLogLevel = "err"
const KafkaSpecCruiseControlTlsSidecarLogLevelWarning KafkaSpecCruiseControlTlsSidecarLogLevel = "warning"
const KafkaSpecCruiseControlTlsSidecarLogLevelNotice KafkaSpecCruiseControlTlsSidecarLogLevel = "notice"
const KafkaSpecCruiseControlTlsSidecarLogLevelInfo KafkaSpecCruiseControlTlsSidecarLogLevel = "info"
const KafkaSpecCruiseControlTlsSidecarLogLevelDebug KafkaSpecCruiseControlTlsSidecarLogLevel = "debug"

// Pod readiness checking.
type KafkaSpecCruiseControlTlsSidecarReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

//type KafkaSpecCruiseControlTlsSidecarResourcesLimits map[string]interface{}

//type KafkaSpecCruiseControlTlsSidecarResourcesRequests map[string]interface{}

// CPU and memory resources to reserve.
type KafkaSpecCruiseControlTlsSidecarResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// TLS sidecar configuration.
type KafkaSpecCruiseControlTlsSidecar struct {
	// The docker image for the container.
	Image *string `json:"image,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecCruiseControlTlsSidecarLivenessProbe `json:"livenessProbe,omitempty"`

	// The log level for the TLS sidecar. Default value is `notice`.
	LogLevel *KafkaSpecCruiseControlTlsSidecarLogLevel `json:"logLevel,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecCruiseControlTlsSidecarReadinessProbe `json:"readinessProbe,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecCruiseControlTlsSidecarResources `json:"resources,omitempty"`
}

// Configuration for Cruise Control deployment. Deploys a Cruise Control instance
// when specified.
type KafkaSpecCruiseControl struct {
	// The Cruise Control `brokerCapacity` configuration.
	BrokerCapacity *KafkaSpecCruiseControlBrokerCapacity `json:"brokerCapacity,omitempty"`

	// The Cruise Control configuration. For a full list of configuration options
	// refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note
	// that properties with the following prefixes cannot be set: bootstrap.servers,
	// client.id, zookeeper., network., security.,
	// failed.brokers.zk.path,webserver.http., webserver.api.urlprefix,
	// webserver.session.path, webserver.accesslog., two.step.,
	// request.reason.required,metric.reporter.sampler.bootstrap.servers,
	// metric.reporter.topic, partition.metric.sample.store.topic,
	// broker.metric.sample.store.topic,capacity.config.file, self.healing., ssl.
	// (with the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,
	// webserver.http.cors.enabled, webserver.http.cors.origin,
	// webserver.http.cors.exposeheaders, webserver.security.enable,
	// webserver.ssl.enable).
	Config *apiextensions.JSON `json:"config,omitempty"`

	// The docker image for the pods.
	Image *string `json:"image,omitempty"`

	// JVM Options for the Cruise Control container.
	JvmOptions *KafkaSpecCruiseControlJvmOptions `json:"jvmOptions,omitempty"`

	// Pod liveness checking for the Cruise Control container.
	LivenessProbe *KafkaSpecCruiseControlLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration (Log4j 2) for Cruise Control.
	Logging *KafkaSpecCruiseControlLogging `json:"logging,omitempty"`

	// Metrics configuration.
	MetricsConfig *KafkaSpecCruiseControlMetricsConfig `json:"metricsConfig,omitempty"`

	// Pod readiness checking for the Cruise Control container.
	ReadinessProbe *KafkaSpecCruiseControlReadinessProbe `json:"readinessProbe,omitempty"`

	// CPU and memory resources to reserve for the Cruise Control container.
	Resources *KafkaSpecCruiseControlResources `json:"resources,omitempty"`

	// Template to specify how Cruise Control resources, `Deployments` and `Pods`, are
	// generated.
	Template *KafkaSpecCruiseControlTemplate `json:"template,omitempty"`

	// TLS sidecar configuration.
	TlsSidecar *KafkaSpecCruiseControlTlsSidecar `json:"tlsSidecar,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplateDeploymentMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplateDeploymentMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecEntityOperatorTemplateDeploymentMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for Entity Operator `Deployment`.
type KafkaSpecEntityOperatorTemplateDeployment struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecEntityOperatorTemplateDeploymentMetadata `json:"metadata,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// The pod's affinity rules.
type KafkaSpecEntityOperatorTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplatePodMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecEntityOperatorTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Configures pod-level security attributes and common container settings.
type KafkaSpecEntityOperatorTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

// Template for Entity Operator `Pods`.
type KafkaSpecEntityOperatorTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecEntityOperatorTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecEntityOperatorTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecEntityOperatorTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecEntityOperatorTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecEntityOperatorTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecEntityOperatorTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecEntityOperatorTemplateServiceAccountMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecEntityOperatorTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for the Entity Operator service account.
type KafkaSpecEntityOperatorTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecEntityOperatorTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for the Entity Operator TLS sidecar container.
type KafkaSpecEntityOperatorTemplateTlsSidecarContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for the Entity Topic Operator container.
type KafkaSpecEntityOperatorTemplateTopicOperatorContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for the Entity User Operator container.
type KafkaSpecEntityOperatorTemplateUserOperatorContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext `json:"securityContext,omitempty"`
}

// Template for Entity Operator resources. The template allows users to specify how
// is the `Deployment` and `Pods` generated.
type KafkaSpecEntityOperatorTemplate struct {
	// Template for Entity Operator `Deployment`.
	Deployment *KafkaSpecEntityOperatorTemplateDeployment `json:"deployment,omitempty"`

	// Template for Entity Operator `Pods`.
	Pod *KafkaSpecEntityOperatorTemplatePod `json:"pod,omitempty"`

	// Template for the Entity Operator service account.
	ServiceAccount *KafkaSpecEntityOperatorTemplateServiceAccount `json:"serviceAccount,omitempty"`

	// Template for the Entity Operator TLS sidecar container.
	TlsSidecarContainer *KafkaSpecEntityOperatorTemplateTlsSidecarContainer `json:"tlsSidecarContainer,omitempty"`

	// Template for the Entity Topic Operator container.
	TopicOperatorContainer *KafkaSpecEntityOperatorTemplateTopicOperatorContainer `json:"topicOperatorContainer,omitempty"`

	// Template for the Entity User Operator container.
	UserOperatorContainer *KafkaSpecEntityOperatorTemplateUserOperatorContainer `json:"userOperatorContainer,omitempty"`
}

// Pod liveness checking.
type KafkaSpecEntityOperatorTlsSidecarLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

type KafkaSpecEntityOperatorTlsSidecarLogLevel string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy, v)
	}
	*j = KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecEntityOperatorTlsSidecarLogLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecEntityOperatorTlsSidecarLogLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecEntityOperatorTlsSidecarLogLevel, v)
	}
	*j = KafkaSpecEntityOperatorTlsSidecarLogLevel(v)
	return nil
}

const KafkaSpecEntityOperatorTlsSidecarLogLevelEmerg KafkaSpecEntityOperatorTlsSidecarLogLevel = "emerg"
const KafkaSpecEntityOperatorTlsSidecarLogLevelAlert KafkaSpecEntityOperatorTlsSidecarLogLevel = "alert"
const KafkaSpecEntityOperatorTlsSidecarLogLevelCrit KafkaSpecEntityOperatorTlsSidecarLogLevel = "crit"
const KafkaSpecEntityOperatorTlsSidecarLogLevelErr KafkaSpecEntityOperatorTlsSidecarLogLevel = "err"
const KafkaSpecEntityOperatorTlsSidecarLogLevelWarning KafkaSpecEntityOperatorTlsSidecarLogLevel = "warning"
const KafkaSpecEntityOperatorTlsSidecarLogLevelNotice KafkaSpecEntityOperatorTlsSidecarLogLevel = "notice"
const KafkaSpecEntityOperatorTlsSidecarLogLevelInfo KafkaSpecEntityOperatorTlsSidecarLogLevel = "info"
const KafkaSpecEntityOperatorTlsSidecarLogLevelDebug KafkaSpecEntityOperatorTlsSidecarLogLevel = "debug"

// Pod readiness checking.
type KafkaSpecEntityOperatorTlsSidecarReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

//type KafkaSpecEntityOperatorTlsSidecarResourcesLimits map[string]interface{}

//type KafkaSpecEntityOperatorTlsSidecarResourcesRequests map[string]interface{}

// CPU and memory resources to reserve.
type KafkaSpecEntityOperatorTlsSidecarResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// TLS sidecar configuration.
type KafkaSpecEntityOperatorTlsSidecar struct {
	// The docker image for the container.
	Image *string `json:"image,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecEntityOperatorTlsSidecarLivenessProbe `json:"livenessProbe,omitempty"`

	// The log level for the TLS sidecar. Default value is `notice`.
	LogLevel *KafkaSpecEntityOperatorTlsSidecarLogLevel `json:"logLevel,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecEntityOperatorTlsSidecarReadinessProbe `json:"readinessProbe,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecEntityOperatorTlsSidecarResources `json:"resources,omitempty"`
}

// A map of -XX options to the JVM.
//type KafkaSpecEntityOperatorTopicOperatorJvmOptionsXX map[string]interface{}

type KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// JVM Options for pods.
type KafkaSpecEntityOperatorTopicOperatorJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

// Pod liveness checking.
type KafkaSpecEntityOperatorTopicOperatorLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaSpecEntityOperatorTopicOperatorLoggingLoggers map[string]interface{}

type KafkaSpecEntityOperatorTopicOperatorLoggingType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem, v)
	}
	*j = KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecEntityOperatorTopicOperatorLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecEntityOperatorTopicOperatorLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecEntityOperatorTopicOperatorLoggingType, v)
	}
	*j = KafkaSpecEntityOperatorTopicOperatorLoggingType(v)
	return nil
}

const KafkaSpecEntityOperatorTopicOperatorLoggingTypeInline KafkaSpecEntityOperatorTopicOperatorLoggingType = "inline"
const KafkaSpecEntityOperatorTopicOperatorLoggingTypeExternal KafkaSpecEntityOperatorTopicOperatorLoggingType = "external"

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// `ConfigMap` entry where the logging configuration is stored.
type KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Logging configuration.
type KafkaSpecEntityOperatorTopicOperatorLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaSpecEntityOperatorTopicOperatorLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom `json:"valueFrom,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecEntityOperatorTopicOperatorLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecEntityOperatorTopicOperatorLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecEntityOperatorTopicOperatorLogging(plain)
	return nil
}

// Pod readiness checking.
type KafkaSpecEntityOperatorTopicOperatorReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

//type KafkaSpecEntityOperatorTopicOperatorResourcesLimits map[string]interface{}

//type KafkaSpecEntityOperatorTopicOperatorResourcesRequests map[string]interface{}

// CPU and memory resources to reserve.
type KafkaSpecEntityOperatorTopicOperatorResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// Pod startup checking.
type KafkaSpecEntityOperatorTopicOperatorStartupProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// Configuration of the Topic Operator.
type KafkaSpecEntityOperatorTopicOperator struct {
	// The image to use for the Topic Operator.
	Image *string `json:"image,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaSpecEntityOperatorTopicOperatorJvmOptions `json:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecEntityOperatorTopicOperatorLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration.
	Logging *KafkaSpecEntityOperatorTopicOperatorLogging `json:"logging,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecEntityOperatorTopicOperatorReadinessProbe `json:"readinessProbe,omitempty"`

	// Interval between periodic reconciliations.
	ReconciliationIntervalSeconds *int32 `json:"reconciliationIntervalSeconds,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecEntityOperatorTopicOperatorResources `json:"resources,omitempty"`

	// Pod startup checking.
	StartupProbe *KafkaSpecEntityOperatorTopicOperatorStartupProbe `json:"startupProbe,omitempty"`

	// The number of attempts at getting topic metadata.
	TopicMetadataMaxAttempts *int32 `json:"topicMetadataMaxAttempts,omitempty"`

	// The namespace the Topic Operator should watch.
	WatchedNamespace *string `json:"watchedNamespace,omitempty"`

	// Timeout for the ZooKeeper session.
	ZookeeperSessionTimeoutSeconds *int32 `json:"zookeeperSessionTimeoutSeconds,omitempty"`
}

// A map of -XX options to the JVM.
//type KafkaSpecEntityOperatorUserOperatorJvmOptionsXX map[string]interface{}

type KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// JVM Options for pods.
type KafkaSpecEntityOperatorUserOperatorJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

// Pod liveness checking.
type KafkaSpecEntityOperatorUserOperatorLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaSpecEntityOperatorUserOperatorLoggingLoggers map[string]interface{}

type KafkaSpecEntityOperatorUserOperatorLoggingType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperStorage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecZookeeperStorage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecZookeeperStorage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecEntityOperatorUserOperatorLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecEntityOperatorUserOperatorLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecEntityOperatorUserOperatorLoggingType, v)
	}
	*j = KafkaSpecEntityOperatorUserOperatorLoggingType(v)
	return nil
}

const KafkaSpecEntityOperatorUserOperatorLoggingTypeInline KafkaSpecEntityOperatorUserOperatorLoggingType = "inline"
const KafkaSpecEntityOperatorUserOperatorLoggingTypeExternal KafkaSpecEntityOperatorUserOperatorLoggingType = "external"

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// `ConfigMap` entry where the logging configuration is stored.
type KafkaSpecEntityOperatorUserOperatorLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Logging configuration.
type KafkaSpecEntityOperatorUserOperatorLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaSpecEntityOperatorUserOperatorLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaSpecEntityOperatorUserOperatorLoggingValueFrom `json:"valueFrom,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecEntityOperatorUserOperatorLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecEntityOperatorUserOperatorLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecEntityOperatorUserOperatorLogging(plain)
	return nil
}

// Pod readiness checking.
type KafkaSpecEntityOperatorUserOperatorReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

//type KafkaSpecEntityOperatorUserOperatorResourcesLimits map[string]interface{}

//type KafkaSpecEntityOperatorUserOperatorResourcesRequests map[string]interface{}

// CPU and memory resources to reserve.
type KafkaSpecEntityOperatorUserOperatorResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// Configuration of the User Operator.
type KafkaSpecEntityOperatorUserOperator struct {
	// The image to use for the User Operator.
	Image *string `json:"image,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaSpecEntityOperatorUserOperatorJvmOptions `json:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecEntityOperatorUserOperatorLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration.
	Logging *KafkaSpecEntityOperatorUserOperatorLogging `json:"logging,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecEntityOperatorUserOperatorReadinessProbe `json:"readinessProbe,omitempty"`

	// Interval between periodic reconciliations.
	ReconciliationIntervalSeconds *int32 `json:"reconciliationIntervalSeconds,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecEntityOperatorUserOperatorResources `json:"resources,omitempty"`

	// The prefix that will be added to the KafkaUser name to be used as the Secret
	// name.
	SecretPrefix *string `json:"secretPrefix,omitempty"`

	// The namespace the User Operator should watch.
	WatchedNamespace *string `json:"watchedNamespace,omitempty"`

	// Timeout for the ZooKeeper session.
	ZookeeperSessionTimeoutSeconds *int32 `json:"zookeeperSessionTimeoutSeconds,omitempty"`
}

// Configuration of the Entity Operator.
type KafkaSpecEntityOperator struct {
	// Template for Entity Operator resources. The template allows users to specify
	// how is the `Deployment` and `Pods` generated.
	Template *KafkaSpecEntityOperatorTemplate `json:"template,omitempty"`

	// TLS sidecar configuration.
	TlsSidecar *KafkaSpecEntityOperatorTlsSidecar `json:"tlsSidecar,omitempty"`

	// Configuration of the Topic Operator.
	TopicOperator *KafkaSpecEntityOperatorTopicOperator `json:"topicOperator,omitempty"`

	// Configuration of the User Operator.
	UserOperator *KafkaSpecEntityOperatorUserOperator `json:"userOperator,omitempty"`
}

type KafkaSpecJmxTransKafkaQueriesElem struct {
	// Determine which attributes of the targeted MBean should be included.
	Attributes []string `json:"attributes"`

	// List of the names of output definitions specified in the
	// spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are
	// pushed to, and in which data format.
	Outputs []string `json:"outputs"`

	// If using wildcards instead of a specific MBean then the data is gathered from
	// multiple MBeans. Otherwise if specifying an MBean then data is gathered from
	// that specified MBean.
	TargetMBean string `json:"targetMBean"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecJmxTransKafkaQueriesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["attributes"]; !ok || v == nil {
		return fmt.Errorf("field attributes: required")
	}
	if v, ok := raw["outputs"]; !ok || v == nil {
		return fmt.Errorf("field outputs: required")
	}
	if v, ok := raw["targetMBean"]; !ok || v == nil {
		return fmt.Errorf("field targetMBean: required")
	}
	type Plain KafkaSpecJmxTransKafkaQueriesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecJmxTransKafkaQueriesElem(plain)
	return nil
}

type KafkaSpecJmxTransOutputDefinitionsElem struct {
	// How many seconds the JmxTrans waits before pushing a new set of data out.
	FlushDelayInSeconds *int32 `json:"flushDelayInSeconds,omitempty"`

	// The DNS/hostname of the remote host that the data is pushed to.
	Host *string `json:"host,omitempty"`

	// Template for setting the name of the output definition. This is used to
	// identify where to send the results of queries should be sent.
	Name string `json:"name"`

	// Template for setting the format of the data that will be pushed.For more
	// information see
	// https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans
	// OutputWriters].
	OutputType string `json:"outputType"`

	// The port of the remote host that the data is pushed to.
	Port *int32 `json:"port,omitempty"`

	// Template for filtering data to be included in response to a wildcard query. For
	// more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans
	// queries].
	TypeNames []string `json:"typeNames,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecJmxTransOutputDefinitionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["outputType"]; !ok || v == nil {
		return fmt.Errorf("field outputType: required")
	}
	type Plain KafkaSpecJmxTransOutputDefinitionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecJmxTransOutputDefinitionsElem(plain)
	return nil
}

//type KafkaSpecJmxTransResourcesLimits map[string]interface{}

//type KafkaSpecJmxTransResourcesRequests map[string]interface{}

// CPU and memory resources to reserve.
type KafkaSpecJmxTransResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

type KafkaSpecJmxTransTemplateContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

type KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Security context for the container.
type KafkaSpecJmxTransTemplateContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// Template for JmxTrans container.
type KafkaSpecJmxTransTemplateContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecJmxTransTemplateContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecJmxTransTemplateContainerSecurityContext `json:"securityContext,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplateDeploymentMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplateDeploymentMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecJmxTransTemplateDeploymentMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for JmxTrans `Deployment`.
type KafkaSpecJmxTransTemplateDeployment struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecJmxTransTemplateDeploymentMetadata `json:"metadata,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

// Kafka broker config properties with the following prefixes cannot be set:
// listeners, advertised., broker., listener., host.name, port,
// inter.broker.listener.name, sasl., ssl., security., password.,
// principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl,
// zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user,
// cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers
// (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites,
// ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions,
// cruise.control.metrics.topic.replication.factor,
// cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries,
// cruise.control.metrics.topic.auto.create.timeout.ms,cruise.control.metrics.topic.min.insync.replicas).
//type KafkaSpecKafkaConfig map[string]interface{}

//type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// The pod's affinity rules.
type KafkaSpecJmxTransTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecJmxTransTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecJmxTransTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaSpecJmxTransTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecJmxTransTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplatePodMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecJmxTransTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecJmxTransTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Configures pod-level security attributes and common container settings.
type KafkaSpecJmxTransTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecJmxTransTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecJmxTransTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

// Template for JmxTrans `Pods`.
type KafkaSpecJmxTransTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecJmxTransTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecJmxTransTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecJmxTransTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecJmxTransTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecJmxTransTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecJmxTransTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecJmxTransTemplateServiceAccountMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecJmxTransTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Template for the JMX Trans service account.
type KafkaSpecJmxTransTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecJmxTransTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

// Template for JmxTrans resources.
type KafkaSpecJmxTransTemplate struct {
	// Template for JmxTrans container.
	Container *KafkaSpecJmxTransTemplateContainer `json:"container,omitempty"`

	// Template for JmxTrans `Deployment`.
	Deployment *KafkaSpecJmxTransTemplateDeployment `json:"deployment,omitempty"`

	// Template for JmxTrans `Pods`.
	Pod *KafkaSpecJmxTransTemplatePod `json:"pod,omitempty"`

	// Template for the JMX Trans service account.
	ServiceAccount *KafkaSpecJmxTransTemplateServiceAccount `json:"serviceAccount,omitempty"`
}

// Configuration for JmxTrans. When the property is present a JmxTrans deployment
// is created for gathering JMX metrics from each Kafka broker. For more
// information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
type KafkaSpecJmxTrans struct {
	// The image to use for the JmxTrans.
	Image *string `json:"image,omitempty"`

	// Queries to send to the Kafka brokers to define what data should be read from
	// each broker. For more information on these properties see,
	// xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema
	// reference].
	KafkaQueries []KafkaSpecJmxTransKafkaQueriesElem `json:"kafkaQueries"`

	// Sets the logging level of the JmxTrans deployment.For more information see,
	// https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans
	// Logging Level].
	LogLevel *string `json:"logLevel,omitempty"`

	// Defines the output hosts that will be referenced later on. For more information
	// on these properties see,
	// xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate`
	// schema reference].
	OutputDefinitions []KafkaSpecJmxTransOutputDefinitionsElem `json:"outputDefinitions"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecJmxTransResources `json:"resources,omitempty"`

	// Template for JmxTrans resources.
	Template *KafkaSpecJmxTransTemplate `json:"template,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecJmxTrans) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["kafkaQueries"]; !ok || v == nil {
		return fmt.Errorf("field kafkaQueries: required")
	}
	if v, ok := raw["outputDefinitions"]; !ok || v == nil {
		return fmt.Errorf("field outputDefinitions: required")
	}
	type Plain KafkaSpecJmxTrans
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecJmxTrans(plain)
	return nil
}

type KafkaSpecKafkaAuthorizationTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaAuthorizationTlsTrustedCertificatesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaSpecKafkaAuthorizationTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaAuthorizationTlsTrustedCertificatesElem(plain)
	return nil
}

type KafkaSpecKafkaAuthorizationType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperStorageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperStorageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperStorageType, v)
	}
	*j = KafkaSpecZookeeperStorageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaAuthorizationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaAuthorizationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaAuthorizationType, v)
	}
	*j = KafkaSpecKafkaAuthorizationType(v)
	return nil
}

const KafkaSpecKafkaAuthorizationTypeSimple KafkaSpecKafkaAuthorizationType = "simple"
const KafkaSpecKafkaAuthorizationTypeOpa KafkaSpecKafkaAuthorizationType = "opa"
const KafkaSpecKafkaAuthorizationTypeKeycloak KafkaSpecKafkaAuthorizationType = "keycloak"
const KafkaSpecKafkaAuthorizationTypeCustom KafkaSpecKafkaAuthorizationType = "custom"

// Authorization configuration for Kafka brokers.
type KafkaSpecKafkaAuthorization struct {
	// Defines whether a Kafka client should be allowed or denied by default when the
	// authorizer fails to query the Open Policy Agent, for example, when it is
	// temporarily unavailable). Defaults to `false` - all actions will be denied.
	AllowOnError *bool `json:"allowOnError,omitempty"`

	// Authorization implementation class, which must be available in classpath.
	AuthorizerClass *string `json:"authorizerClass,omitempty"`

	// OAuth Client ID which the Kafka client can use to authenticate against the
	// OAuth server and use the token endpoint URI.
	ClientId *string `json:"clientId,omitempty"`

	// Whether authorization decision should be delegated to the 'Simple' authorizer
	// if DENIED by Keycloak Authorization Services policies. Default value is
	// `false`.
	DelegateToKafkaAcls *bool `json:"delegateToKafkaAcls,omitempty"`

	// Enable or disable TLS hostname verification. Default value is `false`.
	DisableTlsHostnameVerification *bool `json:"disableTlsHostnameVerification,omitempty"`

	// The expiration of the records kept in the local cache to avoid querying the
	// Open Policy Agent for every request. Defines how often the cached authorization
	// decisions are reloaded from the Open Policy Agent server. In milliseconds.
	// Defaults to `3600000`.
	ExpireAfterMs *int32 `json:"expireAfterMs,omitempty"`

	// The time between two consecutive grants refresh runs in seconds. The default
	// value is 60.
	GrantsRefreshPeriodSeconds *int32 `json:"grantsRefreshPeriodSeconds,omitempty"`

	// The number of threads to use to refresh grants for active sessions. The more
	// threads, the more parallelism, so the sooner the job completes. However, using
	// more threads places a heavier load on the authorization server. The default
	// value is 5.
	GrantsRefreshPoolSize *int32 `json:"grantsRefreshPoolSize,omitempty"`

	// Initial capacity of the local cache used by the authorizer to avoid querying
	// the Open Policy Agent for every request Defaults to `5000`.
	InitialCacheCapacity *int32 `json:"initialCacheCapacity,omitempty"`

	// Maximum capacity of the local cache used by the authorizer to avoid querying
	// the Open Policy Agent for every request. Defaults to `50000`.
	MaximumCacheSize *int32 `json:"maximumCacheSize,omitempty"`

	// List of super users, which are user principals with unlimited access rights.
	SuperUsers []string `json:"superUsers,omitempty"`

	// Indicates whether the custom authorizer supports the APIs for managing ACLs
	// using the Kafka Admin API. Defaults to `false`.
	SupportsAdminApi *bool `json:"supportsAdminApi,omitempty"`

	// Trusted certificates for TLS connection to the OAuth server.
	TlsTrustedCertificates []KafkaSpecKafkaAuthorizationTlsTrustedCertificatesElem `json:"tlsTrustedCertificates,omitempty"`

	// Authorization server token endpoint URI.
	TokenEndpointUri *string `json:"tokenEndpointUri,omitempty"`

	// Authorization type. Currently, the supported types are `simple`, `keycloak`,
	// `opa` and `custom`. `simple` authorization type uses Kafka's
	// `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak`
	// authorization type uses Keycloak Authorization Services for authorization.
	// `opa` authorization type uses Open Policy Agent based authorization.`custom`
	// authorization type uses user-provided implementation for authorization.
	Type KafkaSpecKafkaAuthorizationType `json:"type"`

	// The URL used to connect to the Open Policy Agent server. The URL has to include
	// the policy which will be queried by the authorizer. This option is required.
	Url *string `json:"url,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaAuthorization) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaAuthorization
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaAuthorization(plain)
	return nil
}

type KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperMetricsConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom: required")
	}
	type Plain KafkaSpecZookeeperMetricsConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecZookeeperMetricsConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperMetricsConfigType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperMetricsConfigType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperMetricsConfigType, v)
	}
	*j = KafkaSpecZookeeperMetricsConfigType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaJmxOptionsAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaJmxOptionsAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaJmxOptionsAuthenticationType, v)
	}
	*j = KafkaSpecKafkaJmxOptionsAuthenticationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecZookeeperLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecZookeeperLogging(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperLoggingType, v)
	}
	*j = KafkaSpecZookeeperLoggingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaJmxOptionsAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaJmxOptionsAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaJmxOptionsAuthentication(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperJmxOptionsAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecZookeeperJmxOptionsAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecZookeeperJmxOptionsAuthentication(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecZookeeperJmxOptionsAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecZookeeperJmxOptionsAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecZookeeperJmxOptionsAuthenticationType, v)
	}
	*j = KafkaSpecZookeeperJmxOptionsAuthenticationType(v)
	return nil
}

// Configuration of the Kafka Exporter. Kafka Exporter can provide additional
// metrics, for example lag of consumer group at topic/partition.
type KafkaSpecKafkaExporter struct {
	// Enable Sarama logging, a Go client library used by the Kafka Exporter.
	EnableSaramaLogging *bool `json:"enableSaramaLogging,omitempty"`

	// Regular expression to specify which consumer groups to collect. Default value
	// is `.*`.
	GroupRegex *string `json:"groupRegex,omitempty"`

	// The docker image for the pods.
	Image *string `json:"image,omitempty"`

	// Pod liveness check.
	LivenessProbe *KafkaSpecKafkaExporterLivenessProbe `json:"livenessProbe,omitempty"`

	// Only log messages with the given severity or above. Valid levels: [`info`,
	// `debug`, `trace`]. Default log level is `info`.
	Logging *string `json:"logging,omitempty"`

	// Pod readiness check.
	ReadinessProbe *KafkaSpecKafkaExporterReadinessProbe `json:"readinessProbe,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecKafkaExporterResources `json:"resources,omitempty"`

	// Customization of deployment templates and pods.
	Template *KafkaSpecKafkaExporterTemplate `json:"template,omitempty"`

	// Regular expression to specify which topics to collect. Default value is `.*`.
	TopicRegex *string `json:"topicRegex,omitempty"`
}

// Customization of deployment templates and pods.
type KafkaSpecKafkaExporterTemplate struct {
	// Template for the Kafka Exporter container.
	Container *KafkaSpecKafkaExporterTemplateContainer `json:"container,omitempty"`

	// Template for Kafka Exporter `Deployment`.
	Deployment *KafkaSpecKafkaExporterTemplateDeployment `json:"deployment,omitempty"`

	// Template for Kafka Exporter `Pods`.
	Pod *KafkaSpecKafkaExporterTemplatePod `json:"pod,omitempty"`

	// Template for Kafka Exporter `Service`.
	Service *KafkaSpecKafkaExporterTemplateService `json:"service,omitempty"`

	// Template for the Kafka Exporter service account.
	ServiceAccount *KafkaSpecKafkaExporterTemplateServiceAccount `json:"serviceAccount,omitempty"`
}

// Template for Kafka Exporter `Pods`.
type KafkaSpecKafkaExporterTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecKafkaExporterTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecKafkaExporterTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecKafkaExporterTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaExporterTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecKafkaExporterTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecKafkaExporterTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemAuthenticationClientSecret) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaSpecKafkaListenersElemAuthenticationClientSecret
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElemAuthenticationClientSecret(plain)
	return nil
}

// The pod's affinity rules.
type KafkaSpecKafkaExporterTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemAuthenticationTlsTrustedCertificatesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaSpecKafkaListenersElemAuthenticationTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElemAuthenticationTlsTrustedCertificatesElem(plain)
	return nil
}

// Template for Kafka Exporter `Deployment`.
type KafkaSpecKafkaExporterTemplateDeployment struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaExporterTemplateDeploymentMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaExporterTemplateDeploymentMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemAuthenticationType, v)
	}
	*j = KafkaSpecKafkaListenersElemAuthenticationType(v)
	return nil
}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateDeploymentMetadataLabels map[string]interface{}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateDeploymentMetadataAnnotations map[string]interface{}

// Template for the Kafka Exporter container.
type KafkaSpecKafkaExporterTemplateContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecKafkaExporterTemplateContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecKafkaExporterTemplateContainerSecurityContext `json:"securityContext,omitempty"`
}

// Security context for the container.
type KafkaSpecKafkaExporterTemplateContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaListenersElemAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElemAuthentication(plain)
	return nil
}

type KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationBrokerCertChainAndKey) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaSpecKafkaListenersElemConfigurationBrokerCertChainAndKey
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElemConfigurationBrokerCertChainAndKey(plain)
	return nil
}

type KafkaSpecKafkaExporterTemplateContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// CPU and memory resources to reserve.
type KafkaSpecKafkaExporterResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

//type KafkaSpecKafkaExporterResourcesRequests map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationBrokersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["broker"]; !ok || v == nil {
		return fmt.Errorf("field broker: required")
	}
	type Plain KafkaSpecKafkaListenersElemConfigurationBrokersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElemConfigurationBrokersElem(plain)
	return nil
}

//type KafkaSpecKafkaExporterResourcesLimits map[string]interface{}

// Pod readiness check.
type KafkaSpecKafkaExporterReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy, v)
	}
	*j = KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy(v)
	return nil
}

// Pod liveness check.
type KafkaSpecKafkaExporterLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafka) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["listeners"]; !ok || v == nil {
		return fmt.Errorf("field listeners: required")
	}
	if v, ok := raw["replicas"]; !ok || v == nil {
		return fmt.Errorf("field replicas: required")
	}
	if v, ok := raw["storage"]; !ok || v == nil {
		return fmt.Errorf("field storage: required")
	}
	type Plain KafkaSpecKafka
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafka(plain)
	return nil
}

// Configuration of the Kafka cluster.
type KafkaSpecKafka struct {
	// Authorization configuration for Kafka brokers.
	Authorization *KafkaSpecKafkaAuthorization `json:"authorization,omitempty"`

	// The image of the init container used for initializing the `broker.rack`.
	BrokerRackInitImage *string `json:"brokerRackInitImage,omitempty"`

	// Kafka broker config properties with the following prefixes cannot be set:
	// listeners, advertised., broker., listener., host.name, port,
	// inter.broker.listener.name, sasl., ssl., security., password.,
	// principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl,
	// zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user,
	// cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers
	// (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites,
	// ssl.protocol,
	// ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions,
	// cruise.control.metrics.topic.replication.factor,
	// cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries,
	// cruise.control.metrics.topic.auto.create.timeout.ms,cruise.control.metrics.topic.min.insync.replicas).
	Config *apiextensions.JSON `json:"config,omitempty"`

	// The docker image for the pods. The default value depends on the configured
	// `Kafka.spec.kafka.version`.
	Image *string `json:"image,omitempty"`

	// JMX Options for Kafka brokers.
	JmxOptions *KafkaSpecKafkaJmxOptions `json:"jmxOptions,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaSpecKafkaJvmOptions `json:"jvmOptions,omitempty"`

	// Configures listeners of Kafka brokers.
	Listeners []KafkaSpecKafkaListenersElem `json:"listeners"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecKafkaLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration for Kafka.
	Logging *KafkaSpecKafkaLogging `json:"logging,omitempty"`

	// Metrics configuration.
	MetricsConfig *KafkaSpecKafkaMetricsConfig `json:"metricsConfig,omitempty"`

	// Configuration of the `broker.rack` broker config.
	Rack *KafkaSpecKafkaRack `json:"rack,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecKafkaReadinessProbe `json:"readinessProbe,omitempty"`

	// The number of pods in the cluster.
	Replicas int32 `json:"replicas"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecKafkaResources `json:"resources,omitempty"`

	// Storage configuration (disk). Cannot be updated.
	Storage KafkaSpecKafkaStorage `json:"storage"`

	// Template for Kafka cluster resources. The template allows users to specify how
	// are the `StatefulSet`, `Pods` and `Services` generated.
	Template *KafkaSpecKafkaTemplate `json:"template,omitempty"`

	// The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user
	// documentation to understand the process required to upgrade or downgrade the
	// version.
	Version *string `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy, v)
	}
	*j = KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem, v)
	}
	*j = KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy, v)
	}
	*j = KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem, v)
	}
	*j = KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy, v)
	}
	*j = KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem, v)
	}
	*j = KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy, v)
	}
	*j = KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaStorage) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaStorage
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaStorage(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaStorageVolumesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaStorageVolumesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaStorageVolumesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaStorageVolumesElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaStorageVolumesElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaStorageVolumesElemType, v)
	}
	*j = KafkaSpecKafkaStorageVolumesElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaStorageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaStorageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaStorageType, v)
	}
	*j = KafkaSpecKafkaStorageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaRack) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["topologyKey"]; !ok || v == nil {
		return fmt.Errorf("field topologyKey: required")
	}
	type Plain KafkaSpecKafkaRack
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaRack(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType, v)
	}
	*j = KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaMetricsConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom: required")
	}
	type Plain KafkaSpecKafkaMetricsConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaMetricsConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaMetricsConfigType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaMetricsConfigType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaMetricsConfigType, v)
	}
	*j = KafkaSpecKafkaMetricsConfigType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaLogging(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaSpecKafkaLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaSpecKafkaLoggingType, v)
	}
	*j = KafkaSpecKafkaLoggingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaSpecKafkaListenersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["port"]; !ok || v == nil {
		return fmt.Errorf("field port: required")
	}
	if v, ok := raw["tls"]; !ok || v == nil {
		return fmt.Errorf("field tls: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaSpecKafkaListenersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaSpecKafkaListenersElem(plain)
	return nil
}

type KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaExporterTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaExporterTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplatePodMetadataLabels map[string]interface{}

// Configures pod-level security attributes and common container settings.
type KafkaSpecKafkaExporterTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

// Template for Kafka Exporter `Service`.
type KafkaSpecKafkaExporterTemplateService struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaExporterTemplateServiceMetadata `json:"metadata,omitempty"`
}

// Template for the Kafka Exporter service account.
type KafkaSpecKafkaExporterTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaExporterTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaExporterTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateServiceAccountMetadataLabels map[string]interface{}

// Metadata applied to the resource.
type KafkaSpecKafkaExporterTemplateServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaExporterTemplateServiceMetadataLabels map[string]interface{}

// JMX Options for Kafka brokers.
type KafkaSpecKafkaJmxOptions struct {
	// Authentication configuration for connecting to the JMX port.
	Authentication *KafkaSpecKafkaJmxOptionsAuthentication `json:"authentication,omitempty"`
}

// Authentication configuration for connecting to the JMX port.
type KafkaSpecKafkaJmxOptionsAuthentication struct {
	// Authentication type. Currently the only supported types are
	// `password`.`password` type creates a username and protected port with no TLS.
	Type KafkaSpecKafkaJmxOptionsAuthenticationType `json:"type"`
}

type KafkaSpecKafkaJmxOptionsAuthenticationType string

const KafkaSpecKafkaJmxOptionsAuthenticationTypePassword KafkaSpecKafkaJmxOptionsAuthenticationType = "password"

// JVM Options for pods.
type KafkaSpecKafkaJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaSpecKafkaJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

type KafkaSpecKafkaJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// A map of -XX options to the JVM.
//type KafkaSpecKafkaJvmOptionsXX map[string]interface{}

type KafkaSpecKafkaListenersElem struct {
	// Authentication configuration for this listener.
	Authentication *KafkaSpecKafkaListenersElemAuthentication `json:"authentication,omitempty"`

	// Additional listener configuration.
	Configuration *KafkaSpecKafkaListenersElemConfiguration `json:"configuration,omitempty"`

	// Name of the listener. The name will be used to identify the listener and the
	// related Kubernetes objects. The name has to be unique within given a Kafka
	// cluster. The name can consist of lowercase characters and numbers and be up to
	// 11 characters long.
	Name string `json:"name"`

	// List of peers which should be able to connect to this listener. Peers in this
	// list are combined using a logical OR operation. If this field is empty or
	// missing, all connections will be allowed for this listener. If this field is
	// present and contains at least one item, the listener only allows the traffic
	// which matches at least one item in this list.
	NetworkPolicyPeers []KafkaSpecKafkaListenersElemNetworkPolicyPeersElem `json:"networkPolicyPeers,omitempty"`

	// Port number used by the listener inside Kafka. The port number has to be unique
	// within a given Kafka cluster. Allowed port numbers are 9092 and higher with the
	// exception of ports 9404 and 9999, which are already used for Prometheus and
	// JMX. Depending on the listener type, the port number might not be the same as
	// the port number that connects Kafka clients.
	Port int32 `json:"port"`

	// Enables TLS encryption on the listener. This is a required property.
	Tls bool `json:"tls"`

	// Type of the listener. Currently the supported types are `internal`, `route`,
	// `loadbalancer`, `nodeport` and `ingress`.
	//
	// * `internal` type exposes Kafka internally only within the Kubernetes cluster.
	// * `route` type uses OpenShift Routes to expose Kafka.
	// * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
	// * `nodeport` type uses NodePort type services to expose Kafka.
	// * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.
	//
	Type KafkaSpecKafkaListenersElemType `json:"type"`
}

// Authentication configuration for this listener.
type KafkaSpecKafkaListenersElemAuthentication struct {
	// Configure whether the access token is treated as JWT. This must be set to
	// `false` if the authorization server returns opaque tokens. Defaults to `true`.
	AccessTokenIsJwt *bool `json:"accessTokenIsJwt,omitempty"`

	// Configure whether the access token type check is performed or not. This should
	// be set to `false` if the authorization server does not include 'typ' claim in
	// JWT token. Defaults to `true`.
	CheckAccessTokenType *bool `json:"checkAccessTokenType,omitempty"`

	// Enable or disable audience checking. Audience checks identify the recipients of
	// tokens. If audience checking is enabled, the OAuth Client ID also has to be
	// configured using the `clientId` property. The Kafka broker will reject tokens
	// that do not have its `clientId` in their `aud` (audience) claim.Default value
	// is `false`.
	CheckAudience *bool `json:"checkAudience,omitempty"`

	// Enable or disable issuer checking. By default issuer is checked using the value
	// configured by `validIssuerUri`. Default value is `true`.
	CheckIssuer *bool `json:"checkIssuer,omitempty"`

	// The audience to use when making requests to the authorization server's token
	// endpoint. Used for inter-broker authentication and for configuring OAuth 2.0
	// over PLAIN using the `clientId` and `secret` method.
	ClientAudience *string `json:"clientAudience,omitempty"`

	// OAuth Client ID which the Kafka broker can use to authenticate against the
	// authorization server and use the introspect endpoint URI.
	ClientId *string `json:"clientId,omitempty"`

	// The scope to use when making requests to the authorization server's token
	// endpoint. Used for inter-broker authentication and for configuring OAuth 2.0
	// over PLAIN using the `clientId` and `secret` method.
	ClientScope *string `json:"clientScope,omitempty"`

	// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
	// broker can use to authenticate against the authorization server and use the
	// introspect endpoint URI.
	ClientSecret *KafkaSpecKafkaListenersElemAuthenticationClientSecret `json:"clientSecret,omitempty"`

	// JsonPath filter query to be applied to the JWT token or to the response of the
	// introspection endpoint for additional token validation. Not set by default.
	CustomClaimCheck *string `json:"customClaimCheck,omitempty"`

	// Enable or disable TLS hostname verification. Default value is `false`.
	DisableTlsHostnameVerification *bool `json:"disableTlsHostnameVerification,omitempty"`

	// Enable or disable ECDSA support by installing BouncyCastle crypto provider.
	// ECDSA support is always enabled. The BouncyCastle libraries are no longer
	// packaged with Strimzi. Value is ignored.
	EnableECDSA *bool `json:"enableECDSA,omitempty"`

	// Enable or disable OAuth authentication over SASL_OAUTHBEARER. Default value is
	// `true`.
	EnableOauthBearer *bool `json:"enableOauthBearer,omitempty"`

	// Enable or disable OAuth authentication over SASL_PLAIN. There is no
	// re-authentication support when this mechanism is used. Default value is
	// `false`.
	EnablePlain *bool `json:"enablePlain,omitempty"`

	// The fallback username claim to be used for the user id if the claim specified
	// by `userNameClaim` is not present. This is useful when `client_credentials`
	// authentication only results in the client id being provided in another claim.
	// It only takes effect if `userNameClaim` is set.
	FallbackUserNameClaim *string `json:"fallbackUserNameClaim,omitempty"`

	// The prefix to use with the value of `fallbackUserNameClaim` to construct the
	// user id. This only takes effect if `fallbackUserNameClaim` is true, and the
	// value is present for the claim. Mapping usernames and client ids into the same
	// user id space is useful in preventing name collisions.
	FallbackUserNamePrefix *string `json:"fallbackUserNamePrefix,omitempty"`

	// URI of the token introspection endpoint which can be used to validate opaque
	// non-JWT tokens.
	IntrospectionEndpointUri *string `json:"introspectionEndpointUri,omitempty"`

	// URI of the JWKS certificate endpoint, which can be used for local JWT
	// validation.
	JwksEndpointUri *string `json:"jwksEndpointUri,omitempty"`

	// Configures how often are the JWKS certificates considered valid. The expiry
	// interval has to be at least 60 seconds longer then the refresh interval
	// specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
	JwksExpirySeconds *int32 `json:"jwksExpirySeconds,omitempty"`

	// The minimum pause between two consecutive refreshes. When an unknown signing
	// key is encountered the refresh is scheduled immediately, but will always wait
	// for this minimum pause. Defaults to 1 second.
	JwksMinRefreshPauseSeconds *int32 `json:"jwksMinRefreshPauseSeconds,omitempty"`

	// Configures how often are the JWKS certificates refreshed. The refresh interval
	// has to be at least 60 seconds shorter then the expiry interval specified in
	// `jwksExpirySeconds`. Defaults to 300 seconds.
	JwksRefreshSeconds *int32 `json:"jwksRefreshSeconds,omitempty"`

	// Maximum number of seconds the authenticated session remains valid without
	// re-authentication. This enables Apache Kafka re-authentication feature, and
	// causes sessions to expire when the access token expires. If the access token
	// expires before max time or if max time is reached, the client has to
	// re-authenticate, otherwise the server will drop the connection. Not set by
	// default - the authenticated session does not expire when the access token
	// expires. This option only applies to SASL_OAUTHBEARER authentication mechanism
	// (when `enableOauthBearer` is `true`).
	MaxSecondsWithoutReauthentication *int32 `json:"maxSecondsWithoutReauthentication,omitempty"`

	// Trusted certificates for TLS connection to the OAuth server.
	TlsTrustedCertificates []KafkaSpecKafkaListenersElemAuthenticationTlsTrustedCertificatesElem `json:"tlsTrustedCertificates,omitempty"`

	// URI of the Token Endpoint to use with SASL_PLAIN mechanism when the client
	// authenticates with `clientId` and a `secret`. If set, the client can
	// authenticate over SASL_PLAIN by either setting `username` to `clientId`, and
	// setting `password` to client `secret`, or by setting `username` to account
	// username, and `password` to access token prefixed with `$accessToken:`. If this
	// option is not set, the `password` is always interpreted as an access token
	// (without a prefix), and `username` as the account username (a so called
	// 'no-client-credentials' mode).
	TokenEndpointUri *string `json:"tokenEndpointUri,omitempty"`

	// Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication.
	// `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses
	// TLS Client Authentication. `tls` type is supported only on TLS listeners.
	Type KafkaSpecKafkaListenersElemAuthenticationType `json:"type"`

	// URI of the User Info Endpoint to use as a fallback to obtaining the user id
	// when the Introspection Endpoint does not return information that can be used
	// for the user id.
	UserInfoEndpointUri *string `json:"userInfoEndpointUri,omitempty"`

	// Name of the claim from the JWT authentication token, Introspection Endpoint
	// response or User Info Endpoint response which will be used to extract the user
	// id. Defaults to `sub`.
	UserNameClaim *string `json:"userNameClaim,omitempty"`

	// URI of the token issuer used for authentication.
	ValidIssuerUri *string `json:"validIssuerUri,omitempty"`

	// Valid value for the `token_type` attribute returned by the Introspection
	// Endpoint. No default value, and not checked by default.
	ValidTokenType *string `json:"validTokenType,omitempty"`
}

// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
// broker can use to authenticate against the authorization server and use the
// introspect endpoint URI.
type KafkaSpecKafkaListenersElemAuthenticationClientSecret struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName"`
}

type KafkaSpecKafkaListenersElemAuthenticationTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

type KafkaSpecKafkaListenersElemAuthenticationType string

const KafkaSpecKafkaListenersElemAuthenticationTypeOauth KafkaSpecKafkaListenersElemAuthenticationType = "oauth"
const KafkaSpecKafkaListenersElemAuthenticationTypeScramSha512 KafkaSpecKafkaListenersElemAuthenticationType = "scram-sha-512"
const KafkaSpecKafkaListenersElemAuthenticationTypeTls KafkaSpecKafkaListenersElemAuthenticationType = "tls"

// Additional listener configuration.
type KafkaSpecKafkaListenersElemConfiguration struct {
	// Bootstrap configuration.
	Bootstrap *KafkaSpecKafkaListenersElemConfigurationBootstrap `json:"bootstrap,omitempty"`

	// Reference to the `Secret` which holds the certificate and private key pair
	// which will be used for this listener. The certificate can optionally contain
	// the whole chain. This field can be used only with listeners with enabled TLS
	// encryption.
	BrokerCertChainAndKey *KafkaSpecKafkaListenersElemConfigurationBrokerCertChainAndKey `json:"brokerCertChainAndKey,omitempty"`

	// Per-broker configurations.
	Brokers []KafkaSpecKafkaListenersElemConfigurationBrokersElem `json:"brokers,omitempty"`

	// Configures the `Ingress` class that defines which `Ingress` controller will be
	// used. This field can be used only with `ingress` type listener. If not
	// specified, the default Ingress controller will be used.
	Class *string `json:"class,omitempty"`

	// Specifies whether the service routes external traffic to node-local or
	// cluster-wide endpoints. `Cluster` may cause a second hop to another node and
	// obscures the client source IP. `Local` avoids a second hop for LoadBalancer and
	// Nodeport type services and preserves the client source IP (when supported by
	// the infrastructure). If unspecified, Kubernetes will use `Cluster` as the
	// default.This field can be used only with `loadbalancer` or `nodeport` type
	// listener.
	ExternalTrafficPolicy *KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy `json:"externalTrafficPolicy,omitempty"`

	// A list of finalizers which will be configured for the `LoadBalancer` type
	// Services created for this listener. If supported by the platform, the finalizer
	// `service.kubernetes.io/load-balancer-cleanup` to make sure that the external
	// load balancer is deleted together with the service.For more information, see
	// https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers.
	// This field can be used only with `loadbalancer` type listeners.
	Finalizers []string `json:"finalizers,omitempty"`

	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from
	// which clients can connect to load balancer type listeners. If supported by the
	// platform, traffic through the loadbalancer is restricted to the specified CIDR
	// ranges. This field is applicable only for loadbalancer type services and is
	// ignored if the cloud provider does not support the feature. For more
	// information, see
	// https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/.
	// This field can be used only with `loadbalancer` type listener.
	LoadBalancerSourceRanges []string `json:"loadBalancerSourceRanges,omitempty"`

	// The maximum connection creation rate we allow in this listener at any time. New
	// connections will be throttled if the limit is reached.
	MaxConnectionCreationRate *int32 `json:"maxConnectionCreationRate,omitempty"`

	// The maximum number of connections we allow for this listener in the broker at
	// any time. New connections are blocked if the limit is reached.
	MaxConnections *int32 `json:"maxConnections,omitempty"`

	// Defines which address type should be used as the node address. Available types
	// are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`.
	// By default, the addresses will be used in the following order (the first one
	// found will be used):
	//
	// * `ExternalDNS`
	// * `ExternalIP`
	// * `InternalDNS`
	// * `InternalIP`
	// * `Hostname`
	//
	// This field is used to select the preferred address type, which is checked
	// first. If no address is found for this address type, the other types are
	// checked in the default order. This field can only be used with `nodeport` type
	// listener.
	PreferredNodePortAddressType *KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType `json:"preferredNodePortAddressType,omitempty"`

	// Configures whether the Kubernetes service DNS domain should be used or not. If
	// set to `true`, the generated addresses will contain the service DNS domain
	// suffix (by default `.cluster.local`, can be configured using environment
	// variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can
	// be used only with `internal` type listener.
	UseServiceDnsDomain *bool `json:"useServiceDnsDomain,omitempty"`
}

// Bootstrap configuration.
type KafkaSpecKafkaListenersElemConfigurationBootstrap struct {
	// Additional alternative names for the bootstrap service. The alternative names
	// will be added to the list of subject alternative names of the TLS certificates.
	AlternativeNames []string `json:"alternativeNames,omitempty"`

	// Annotations that will be added to the `Ingress`, `Route`, or `Service`
	// resource. You can use this field to configure DNS providers such as External
	// DNS. This field can be used only with `loadbalancer`, `nodeport`, `route`, or
	// `ingress` type listeners.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// The bootstrap host. This field will be used in the Ingress resource or in the
	// Route resource to specify the desired hostname. This field can be used only
	// with `route` (optional) or `ingress` (required) type listeners.
	Host *string `json:"host,omitempty"`

	// Labels that will be added to the `Ingress`, `Route`, or `Service` resource.
	// This field can be used only with `loadbalancer`, `nodeport`, `route`, or
	// `ingress` type listeners.
	Labels *apiextensions.JSON `json:"labels,omitempty"`

	// The loadbalancer is requested with the IP address specified in this field. This
	// feature depends on whether the underlying cloud provider supports specifying
	// the `loadBalancerIP` when a load balancer is created. This field is ignored if
	// the cloud provider does not support the feature.This field can be used only
	// with `loadbalancer` type listener.
	LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`

	// Node port for the bootstrap service. This field can be used only with
	// `nodeport` type listener.
	NodePort *int32 `json:"nodePort,omitempty"`
}

// Annotations that will be added to the `Ingress`, `Route`, or `Service` resource.
// You can use this field to configure DNS providers such as External DNS. This
// field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress`
// type listeners.
//type KafkaSpecKafkaListenersElemConfigurationBootstrapAnnotations map[string]interface{}

// Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This
// field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress`
// type listeners.
//type KafkaSpecKafkaListenersElemConfigurationBootstrapLabels map[string]interface{}

// Reference to the `Secret` which holds the certificate and private key pair which
// will be used for this listener. The certificate can optionally contain the whole
// chain. This field can be used only with listeners with enabled TLS encryption.
type KafkaSpecKafkaListenersElemConfigurationBrokerCertChainAndKey struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the private key in the Secret.
	Key string `json:"key"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

type KafkaSpecKafkaListenersElemConfigurationBrokersElem struct {
	// The host name which will be used in the brokers' `advertised.brokers`.
	AdvertisedHost *string `json:"advertisedHost,omitempty"`

	// The port number which will be used in the brokers' `advertised.brokers`.
	AdvertisedPort *int32 `json:"advertisedPort,omitempty"`

	// Annotations that will be added to the `Ingress` or `Service` resource. You can
	// use this field to configure DNS providers such as External DNS. This field can
	// be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// ID of the kafka broker (broker identifier). Broker IDs start from 0 and
	// correspond to the number of broker replicas.
	Broker int32 `json:"broker"`

	// The broker host. This field will be used in the Ingress resource or in the
	// Route resource to specify the desired hostname. This field can be used only
	// with `route` (optional) or `ingress` (required) type listeners.
	Host *string `json:"host,omitempty"`

	// Labels that will be added to the `Ingress`, `Route`, or `Service` resource.
	// This field can be used only with `loadbalancer`, `nodeport`, `route`, or
	// `ingress` type listeners.
	Labels *apiextensions.JSON `json:"labels,omitempty"`

	// The loadbalancer is requested with the IP address specified in this field. This
	// feature depends on whether the underlying cloud provider supports specifying
	// the `loadBalancerIP` when a load balancer is created. This field is ignored if
	// the cloud provider does not support the feature.This field can be used only
	// with `loadbalancer` type listener.
	LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`

	// Node port for the per-broker service. This field can be used only with
	// `nodeport` type listener.
	NodePort *int32 `json:"nodePort,omitempty"`
}

// Annotations that will be added to the `Ingress` or `Service` resource. You can
// use this field to configure DNS providers such as External DNS. This field can
// be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
//type KafkaSpecKafkaListenersElemConfigurationBrokersElemAnnotations map[string]interface{}

// Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This
// field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress`
// type listeners.
//type KafkaSpecKafkaListenersElemConfigurationBrokersElemLabels map[string]interface{}

type KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy string

const KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicyCluster KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy = "Cluster"
const KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicyLocal KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy = "Local"

type KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem string

const KafkaSpecKafkaListenersElemConfigurationIpFamiliesElemIPv4 KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem = "IPv4"
const KafkaSpecKafkaListenersElemConfigurationIpFamiliesElemIPv6 KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem = "IPv6"

type KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy string

const KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicyPreferDualStack KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy = "PreferDualStack"
const KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicyRequireDualStack KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy = "RequireDualStack"
const KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicySingleStack KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy = "SingleStack"

type KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType string

const KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressTypeExternalDNS KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = "ExternalDNS"
const KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressTypeExternalIP KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = "ExternalIP"
const KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressTypeHostname KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = "Hostname"
const KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressTypeInternalDNS KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = "InternalDNS"
const KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressTypeInternalIP KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = "InternalIP"

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElem struct {
	// IpBlock corresponds to the JSON schema field "ipBlock".
	IpBlock *KafkaSpecKafkaListenersElemNetworkPolicyPeersElemIpBlock `json:"ipBlock,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaListenersElemNetworkPolicyPeersElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// PodSelector corresponds to the JSON schema field "podSelector".
	PodSelector *KafkaSpecKafkaListenersElemNetworkPolicyPeersElemPodSelector `json:"podSelector,omitempty"`
}

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemIpBlock struct {
	// Cidr corresponds to the JSON schema field "cidr".
	Cidr *string `json:"cidr,omitempty"`

	// Except corresponds to the JSON schema field "except".
	Except []string `json:"except,omitempty"`
}

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaListenersElemNetworkPolicyPeersElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemPodSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaListenersElemNetworkPolicyPeersElemPodSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemPodSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaListenersElemNetworkPolicyPeersElemPodSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaListenersElemType string

const KafkaSpecKafkaListenersElemTypeIngress KafkaSpecKafkaListenersElemType = "ingress"
const KafkaSpecKafkaListenersElemTypeInternal KafkaSpecKafkaListenersElemType = "internal"
const KafkaSpecKafkaListenersElemTypeLoadbalancer KafkaSpecKafkaListenersElemType = "loadbalancer"
const KafkaSpecKafkaListenersElemTypeNodeport KafkaSpecKafkaListenersElemType = "nodeport"
const KafkaSpecKafkaListenersElemTypeRoute KafkaSpecKafkaListenersElemType = "route"

// Pod liveness checking.
type KafkaSpecKafkaLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// Logging configuration for Kafka.
type KafkaSpecKafkaLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaSpecKafkaLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaSpecKafkaLoggingValueFrom `json:"valueFrom,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaSpecKafkaLoggingLoggers map[string]interface{}

type KafkaSpecKafkaLoggingType string

const KafkaSpecKafkaLoggingTypeExternal KafkaSpecKafkaLoggingType = "external"
const KafkaSpecKafkaLoggingTypeInline KafkaSpecKafkaLoggingType = "inline"

// `ConfigMap` entry where the logging configuration is stored.
type KafkaSpecKafkaLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecKafkaLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecKafkaLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Metrics configuration.
type KafkaSpecKafkaMetricsConfig struct {
	// Metrics type. Only 'jmxPrometheusExporter' supported currently.
	Type KafkaSpecKafkaMetricsConfigType `json:"type"`

	// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
	// details of the structure of this configuration, see the {JMXExporter}.
	ValueFrom KafkaSpecKafkaMetricsConfigValueFrom `json:"valueFrom"`
}

type KafkaSpecKafkaMetricsConfigType string

const KafkaSpecKafkaMetricsConfigTypeJmxPrometheusExporter KafkaSpecKafkaMetricsConfigType = "jmxPrometheusExporter"

// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
// details of the structure of this configuration, see the {JMXExporter}.
type KafkaSpecKafkaMetricsConfigValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Configuration of the `broker.rack` broker config.
type KafkaSpecKafkaRack struct {
	// A key that matches labels assigned to the Kubernetes cluster nodes. The value
	// of the label is used to set the broker's `broker.rack` config and `client.rack`
	// in Kafka Connect.
	TopologyKey string `json:"topologyKey"`
}

// Pod readiness checking.
type KafkaSpecKafkaReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// CPU and memory resources to reserve.
type KafkaSpecKafkaResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

//type KafkaSpecKafkaResourcesLimits map[string]interface{}

//type KafkaSpecKafkaResourcesRequests map[string]interface{}

// Storage configuration (disk). Cannot be updated.
type KafkaSpecKafkaStorage struct {
	// The storage class to use for dynamic volume allocation.
	Class *string `json:"class,omitempty"`

	// Specifies if the persistent volume claim has to be deleted when the cluster is
	// un-deployed.
	DeleteClaim *bool `json:"deleteClaim,omitempty"`

	// Storage identification number. It is mandatory only for storage volumes defined
	// in a storage of type 'jbod'.
	Id *int32 `json:"id,omitempty"`

	// Overrides for individual brokers. The `overrides` field allows to specify a
	// different configuration for different brokers.
	Overrides []KafkaSpecKafkaStorageOverridesElem `json:"overrides,omitempty"`

	// Specifies a specific persistent volume to use. It contains key:value pairs
	// representing labels for selecting such a volume.
	Selector *apiextensions.JSON `json:"selector,omitempty"`

	// When type=persistent-claim, defines the size of the persistent volume claim
	// (i.e 1Gi). Mandatory when type=persistent-claim.
	Size *string `json:"size,omitempty"`

	// When type=ephemeral, defines the total amount of local storage required for
	// this EmptyDir volume (for example 1Gi).
	SizeLimit *string `json:"sizeLimit,omitempty"`

	// Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
	Type KafkaSpecKafkaStorageType `json:"type"`

	// List of volumes as Storage objects representing the JBOD disks array.
	Volumes []KafkaSpecKafkaStorageVolumesElem `json:"volumes,omitempty"`
}

type KafkaSpecKafkaStorageOverridesElem struct {
	// Id of the kafka broker (broker identifier).
	Broker *int32 `json:"broker,omitempty"`

	// The storage class to use for dynamic volume allocation for this broker.
	Class *string `json:"class,omitempty"`
}

// Specifies a specific persistent volume to use. It contains key:value pairs
// representing labels for selecting such a volume.
//type KafkaSpecKafkaStorageSelector map[string]interface{}

type KafkaSpecKafkaStorageType string

const KafkaSpecKafkaStorageTypeEphemeral KafkaSpecKafkaStorageType = "ephemeral"
const KafkaSpecKafkaStorageTypeJbod KafkaSpecKafkaStorageType = "jbod"
const KafkaSpecKafkaStorageTypePersistentClaim KafkaSpecKafkaStorageType = "persistent-claim"

type KafkaSpecKafkaStorageVolumesElem struct {
	// The storage class to use for dynamic volume allocation.
	Class *string `json:"class,omitempty"`

	// Specifies if the persistent volume claim has to be deleted when the cluster is
	// un-deployed.
	DeleteClaim *bool `json:"deleteClaim,omitempty"`

	// Storage identification number. It is mandatory only for storage volumes defined
	// in a storage of type 'jbod'.
	Id *int32 `json:"id,omitempty"`

	// Overrides for individual brokers. The `overrides` field allows to specify a
	// different configuration for different brokers.
	Overrides []KafkaSpecKafkaStorageVolumesElemOverridesElem `json:"overrides,omitempty"`

	// Specifies a specific persistent volume to use. It contains key:value pairs
	// representing labels for selecting such a volume.
	Selector *apiextensions.JSON `json:"selector,omitempty"`

	// When type=persistent-claim, defines the size of the persistent volume claim
	// (i.e 1Gi). Mandatory when type=persistent-claim.
	Size *string `json:"size,omitempty"`

	// When type=ephemeral, defines the total amount of local storage required for
	// this EmptyDir volume (for example 1Gi).
	SizeLimit *string `json:"sizeLimit,omitempty"`

	// Storage type, must be either 'ephemeral' or 'persistent-claim'.
	Type KafkaSpecKafkaStorageVolumesElemType `json:"type"`
}

type KafkaSpecKafkaStorageVolumesElemOverridesElem struct {
	// Id of the kafka broker (broker identifier).
	Broker *int32 `json:"broker,omitempty"`

	// The storage class to use for dynamic volume allocation for this broker.
	Class *string `json:"class,omitempty"`
}

// Specifies a specific persistent volume to use. It contains key:value pairs
// representing labels for selecting such a volume.
//type KafkaSpecKafkaStorageVolumesElemSelector map[string]interface{}

type KafkaSpecKafkaStorageVolumesElemType string

const KafkaSpecKafkaStorageVolumesElemTypeEphemeral KafkaSpecKafkaStorageVolumesElemType = "ephemeral"
const KafkaSpecKafkaStorageVolumesElemTypePersistentClaim KafkaSpecKafkaStorageVolumesElemType = "persistent-claim"

// Template for Kafka cluster resources. The template allows users to specify how
// are the `StatefulSet`, `Pods` and `Services` generated.
type KafkaSpecKafkaTemplate struct {
	// Template for Kafka bootstrap `Service`.
	BootstrapService *KafkaSpecKafkaTemplateBootstrapService `json:"bootstrapService,omitempty"`

	// Template for Kafka broker `Service`.
	BrokersService *KafkaSpecKafkaTemplateBrokersService `json:"brokersService,omitempty"`

	// Template for Secret with Kafka Cluster certificate public key.
	ClusterCaCert *KafkaSpecKafkaTemplateClusterCaCert `json:"clusterCaCert,omitempty"`

	// Template for the Kafka ClusterRoleBinding.
	ClusterRoleBinding *KafkaSpecKafkaTemplateClusterRoleBinding `json:"clusterRoleBinding,omitempty"`

	// Template for Kafka external bootstrap `Ingress`.
	ExternalBootstrapIngress *KafkaSpecKafkaTemplateExternalBootstrapIngress `json:"externalBootstrapIngress,omitempty"`

	// Template for Kafka external bootstrap `Route`.
	ExternalBootstrapRoute *KafkaSpecKafkaTemplateExternalBootstrapRoute `json:"externalBootstrapRoute,omitempty"`

	// Template for Kafka external bootstrap `Service`.
	ExternalBootstrapService *KafkaSpecKafkaTemplateExternalBootstrapService `json:"externalBootstrapService,omitempty"`

	// Template for the Kafka init container.
	InitContainer *KafkaSpecKafkaTemplateInitContainer `json:"initContainer,omitempty"`

	// Template for Secret of the Kafka Cluster JMX authentication.
	JmxSecret *KafkaSpecKafkaTemplateJmxSecret `json:"jmxSecret,omitempty"`

	// Template for the Kafka broker container.
	KafkaContainer *KafkaSpecKafkaTemplateKafkaContainer `json:"kafkaContainer,omitempty"`

	// Template for Kafka per-pod `Ingress` used for access from outside of
	// Kubernetes.
	PerPodIngress *KafkaSpecKafkaTemplatePerPodIngress `json:"perPodIngress,omitempty"`

	// Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
	PerPodRoute *KafkaSpecKafkaTemplatePerPodRoute `json:"perPodRoute,omitempty"`

	// Template for Kafka per-pod `Services` used for access from outside of
	// Kubernetes.
	PerPodService *KafkaSpecKafkaTemplatePerPodService `json:"perPodService,omitempty"`

	// Template for all Kafka `PersistentVolumeClaims`.
	PersistentVolumeClaim *KafkaSpecKafkaTemplatePersistentVolumeClaim `json:"persistentVolumeClaim,omitempty"`

	// Template for Kafka `Pods`.
	Pod *KafkaSpecKafkaTemplatePod `json:"pod,omitempty"`

	// Template for Kafka `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaSpecKafkaTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty"`

	// Template for the Kafka service account.
	ServiceAccount *KafkaSpecKafkaTemplateServiceAccount `json:"serviceAccount,omitempty"`

	// Template for Kafka `StatefulSet`.
	Statefulset *KafkaSpecKafkaTemplateStatefulset `json:"statefulset,omitempty"`
}

// Template for Kafka bootstrap `Service`.
type KafkaSpecKafkaTemplateBootstrapService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateBootstrapServiceMetadata `json:"metadata,omitempty"`
}

type KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem string

const KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElemIPv4 KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem = "IPv4"
const KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElemIPv6 KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem = "IPv6"

type KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy string

const KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicyPreferDualStack KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy = "PreferDualStack"
const KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicyRequireDualStack KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy = "RequireDualStack"
const KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicySingleStack KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy = "SingleStack"

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateBootstrapServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateBootstrapServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateBootstrapServiceMetadataLabels map[string]interface{}

// Template for Kafka broker `Service`.
type KafkaSpecKafkaTemplateBrokersService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateBrokersServiceMetadata `json:"metadata,omitempty"`
}

type KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem string

const KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElemIPv4 KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem = "IPv4"
const KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElemIPv6 KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem = "IPv6"

type KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy string

const KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicyPreferDualStack KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy = "PreferDualStack"
const KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicyRequireDualStack KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy = "RequireDualStack"
const KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicySingleStack KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy = "SingleStack"

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateBrokersServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateBrokersServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateBrokersServiceMetadataLabels map[string]interface{}

// Template for Secret with Kafka Cluster certificate public key.
type KafkaSpecKafkaTemplateClusterCaCert struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateClusterCaCertMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateClusterCaCertMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateClusterCaCertMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateClusterCaCertMetadataLabels map[string]interface{}

// Template for the Kafka ClusterRoleBinding.
type KafkaSpecKafkaTemplateClusterRoleBinding struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateClusterRoleBindingMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateClusterRoleBindingMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateClusterRoleBindingMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateClusterRoleBindingMetadataLabels map[string]interface{}

// Template for Kafka external bootstrap `Ingress`.
type KafkaSpecKafkaTemplateExternalBootstrapIngress struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataLabels map[string]interface{}

// Template for Kafka external bootstrap `Route`.
type KafkaSpecKafkaTemplateExternalBootstrapRoute struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataLabels map[string]interface{}

// Template for Kafka external bootstrap `Service`.
type KafkaSpecKafkaTemplateExternalBootstrapService struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataLabels map[string]interface{}

// Template for the Kafka init container.
type KafkaSpecKafkaTemplateInitContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecKafkaTemplateInitContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecKafkaTemplateInitContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaSpecKafkaTemplateInitContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaSpecKafkaTemplateInitContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Template for Secret of the Kafka Cluster JMX authentication.
type KafkaSpecKafkaTemplateJmxSecret struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateJmxSecretMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateJmxSecretMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateJmxSecretMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateJmxSecretMetadataLabels map[string]interface{}

// Template for the Kafka broker container.
type KafkaSpecKafkaTemplateKafkaContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecKafkaTemplateKafkaContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecKafkaTemplateKafkaContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaSpecKafkaTemplateKafkaContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaSpecKafkaTemplateKafkaContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
type KafkaSpecKafkaTemplatePerPodIngress struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplatePerPodIngressMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplatePerPodIngressMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodIngressMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodIngressMetadataLabels map[string]interface{}

// Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
type KafkaSpecKafkaTemplatePerPodRoute struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplatePerPodRouteMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplatePerPodRouteMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodRouteMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodRouteMetadataLabels map[string]interface{}

// Template for Kafka per-pod `Services` used for access from outside of
// Kubernetes.
type KafkaSpecKafkaTemplatePerPodService struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplatePerPodServiceMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplatePerPodServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePerPodServiceMetadataLabels map[string]interface{}

// Template for all Kafka `PersistentVolumeClaims`.
type KafkaSpecKafkaTemplatePersistentVolumeClaim struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataLabels map[string]interface{}

// Template for Kafka `Pods`.
type KafkaSpecKafkaTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecKafkaTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecKafkaTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecKafkaTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecKafkaTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecKafkaTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// The pod's affinity rules.
type KafkaSpecKafkaTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecKafkaTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecKafkaTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

// Template for Kafka `PodDisruptionBudget`.
type KafkaSpecKafkaTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
	Metadata *KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty"`
}

// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
type KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataLabels map[string]interface{}

type KafkaSpecKafkaTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecKafkaTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplatePodMetadataLabels map[string]interface{}

// Configures pod-level security attributes and common container settings.
type KafkaSpecKafkaTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecKafkaTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecKafkaTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaSpecKafkaTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

type KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecKafkaTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

// Template for the Kafka service account.
type KafkaSpecKafkaTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateServiceAccountMetadataLabels map[string]interface{}

// Template for Kafka `StatefulSet`.
type KafkaSpecKafkaTemplateStatefulset struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecKafkaTemplateStatefulsetMetadata `json:"metadata,omitempty"`

	// PodManagementPolicy which will be used for this StatefulSet. Valid values are
	// `Parallel` and `OrderedReady`. Defaults to `Parallel`.
	PodManagementPolicy *KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy `json:"podManagementPolicy,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecKafkaTemplateStatefulsetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateStatefulsetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecKafkaTemplateStatefulsetMetadataLabels map[string]interface{}

type KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy string

const KafkaSpecKafkaTemplateStatefulsetPodManagementPolicyOrderedReady KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy = "OrderedReady"
const KafkaSpecKafkaTemplateStatefulsetPodManagementPolicyParallel KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy = "Parallel"

// Configuration of the ZooKeeper cluster.
type KafkaSpecZookeeper struct {
	// The ZooKeeper broker config. Properties with the following prefixes cannot be
	// set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth,
	// requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled,
	// reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl.,
	// serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol,
	// ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols,
	// ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification,
	// ssl.quorum.hostnameVerification).
	Config *apiextensions.JSON `json:"config,omitempty"`

	// The docker image for the pods.
	Image *string `json:"image,omitempty"`

	// JMX Options for Zookeeper nodes.
	JmxOptions *KafkaSpecZookeeperJmxOptions `json:"jmxOptions,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaSpecZookeeperJvmOptions `json:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaSpecZookeeperLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration for ZooKeeper.
	Logging *KafkaSpecZookeeperLogging `json:"logging,omitempty"`

	// Metrics configuration.
	MetricsConfig *KafkaSpecZookeeperMetricsConfig `json:"metricsConfig,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaSpecZookeeperReadinessProbe `json:"readinessProbe,omitempty"`

	// The number of pods in the cluster.
	Replicas int32 `json:"replicas"`

	// CPU and memory resources to reserve.
	Resources *KafkaSpecZookeeperResources `json:"resources,omitempty"`

	// Storage configuration (disk). Cannot be updated.
	Storage KafkaSpecZookeeperStorage `json:"storage"`

	// Template for ZooKeeper cluster resources. The template allows users to specify
	// how are the `StatefulSet`, `Pods` and `Services` generated.
	Template *KafkaSpecZookeeperTemplate `json:"template,omitempty"`
}

// The ZooKeeper broker config. Properties with the following prefixes cannot be
// set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth,
// requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled,
// reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl.,
// serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol,
// ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols,
// ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification,
// ssl.quorum.hostnameVerification).
//type KafkaSpecZookeeperConfig map[string]interface{}

// JMX Options for Zookeeper nodes.
type KafkaSpecZookeeperJmxOptions struct {
	// Authentication configuration for connecting to the JMX port.
	Authentication *KafkaSpecZookeeperJmxOptionsAuthentication `json:"authentication,omitempty"`
}

// Authentication configuration for connecting to the JMX port.
type KafkaSpecZookeeperJmxOptionsAuthentication struct {
	// Authentication type. Currently the only supported types are
	// `password`.`password` type creates a username and protected port with no TLS.
	Type KafkaSpecZookeeperJmxOptionsAuthenticationType `json:"type"`
}

type KafkaSpecZookeeperJmxOptionsAuthenticationType string

const KafkaSpecZookeeperJmxOptionsAuthenticationTypePassword KafkaSpecZookeeperJmxOptionsAuthenticationType = "password"

// JVM Options for pods.
type KafkaSpecZookeeperJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

type KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// A map of -XX options to the JVM.
//type KafkaSpecZookeeperJvmOptionsXX map[string]interface{}

// Pod liveness checking.
type KafkaSpecZookeeperLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// Logging configuration for ZooKeeper.
type KafkaSpecZookeeperLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaSpecZookeeperLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaSpecZookeeperLoggingValueFrom `json:"valueFrom,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaSpecZookeeperLoggingLoggers map[string]interface{}

type KafkaSpecZookeeperLoggingType string

const KafkaSpecZookeeperLoggingTypeExternal KafkaSpecZookeeperLoggingType = "external"
const KafkaSpecZookeeperLoggingTypeInline KafkaSpecZookeeperLoggingType = "inline"

// `ConfigMap` entry where the logging configuration is stored.
type KafkaSpecZookeeperLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Metrics configuration.
type KafkaSpecZookeeperMetricsConfig struct {
	// Metrics type. Only 'jmxPrometheusExporter' supported currently.
	Type KafkaSpecZookeeperMetricsConfigType `json:"type"`

	// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
	// details of the structure of this configuration, see the {JMXExporter}.
	ValueFrom KafkaSpecZookeeperMetricsConfigValueFrom `json:"valueFrom"`
}

type KafkaSpecZookeeperMetricsConfigType string

const KafkaSpecZookeeperMetricsConfigTypeJmxPrometheusExporter KafkaSpecZookeeperMetricsConfigType = "jmxPrometheusExporter"

// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
// details of the structure of this configuration, see the {JMXExporter}.
type KafkaSpecZookeeperMetricsConfigValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Pod readiness checking.
type KafkaSpecZookeeperReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// CPU and memory resources to reserve.
type KafkaSpecZookeeperResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

//type KafkaSpecZookeeperResourcesLimits map[string]interface{}

//type KafkaSpecZookeeperResourcesRequests map[string]interface{}

// Storage configuration (disk). Cannot be updated.
type KafkaSpecZookeeperStorage struct {
	// The storage class to use for dynamic volume allocation.
	Class *string `json:"class,omitempty"`

	// Specifies if the persistent volume claim has to be deleted when the cluster is
	// un-deployed.
	DeleteClaim *bool `json:"deleteClaim,omitempty"`

	// Storage identification number. It is mandatory only for storage volumes defined
	// in a storage of type 'jbod'.
	Id *int32 `json:"id,omitempty"`

	// Overrides for individual brokers. The `overrides` field allows to specify a
	// different configuration for different brokers.
	Overrides []KafkaSpecZookeeperStorageOverridesElem `json:"overrides,omitempty"`

	// Specifies a specific persistent volume to use. It contains key:value pairs
	// representing labels for selecting such a volume.
	Selector *apiextensions.JSON `json:"selector,omitempty"`

	// When type=persistent-claim, defines the size of the persistent volume claim
	// (i.e 1Gi). Mandatory when type=persistent-claim.
	Size *string `json:"size,omitempty"`

	// When type=ephemeral, defines the total amount of local storage required for
	// this EmptyDir volume (for example 1Gi).
	SizeLimit *string `json:"sizeLimit,omitempty"`

	// Storage type, must be either 'ephemeral' or 'persistent-claim'.
	Type KafkaSpecZookeeperStorageType `json:"type"`
}

type KafkaSpecZookeeperStorageOverridesElem struct {
	// Id of the kafka broker (broker identifier).
	Broker *int32 `json:"broker,omitempty"`

	// The storage class to use for dynamic volume allocation for this broker.
	Class *string `json:"class,omitempty"`
}

// Specifies a specific persistent volume to use. It contains key:value pairs
// representing labels for selecting such a volume.
//type KafkaSpecZookeeperStorageSelector map[string]interface{}

type KafkaSpecZookeeperStorageType string

const KafkaSpecZookeeperStorageTypeEphemeral KafkaSpecZookeeperStorageType = "ephemeral"
const KafkaSpecZookeeperStorageTypePersistentClaim KafkaSpecZookeeperStorageType = "persistent-claim"

// Template for ZooKeeper cluster resources. The template allows users to specify
// how are the `StatefulSet`, `Pods` and `Services` generated.
type KafkaSpecZookeeperTemplate struct {
	// Template for ZooKeeper client `Service`.
	ClientService *KafkaSpecZookeeperTemplateClientService `json:"clientService,omitempty"`

	// Template for Secret of the Zookeeper Cluster JMX authentication.
	JmxSecret *KafkaSpecZookeeperTemplateJmxSecret `json:"jmxSecret,omitempty"`

	// Template for ZooKeeper nodes `Service`.
	NodesService *KafkaSpecZookeeperTemplateNodesService `json:"nodesService,omitempty"`

	// Template for all ZooKeeper `PersistentVolumeClaims`.
	PersistentVolumeClaim *KafkaSpecZookeeperTemplatePersistentVolumeClaim `json:"persistentVolumeClaim,omitempty"`

	// Template for ZooKeeper `Pods`.
	Pod *KafkaSpecZookeeperTemplatePod `json:"pod,omitempty"`

	// Template for ZooKeeper `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaSpecZookeeperTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty"`

	// Template for the ZooKeeper service account.
	ServiceAccount *KafkaSpecZookeeperTemplateServiceAccount `json:"serviceAccount,omitempty"`

	// Template for ZooKeeper `StatefulSet`.
	Statefulset *KafkaSpecZookeeperTemplateStatefulset `json:"statefulset,omitempty"`

	// Template for the ZooKeeper container.
	ZookeeperContainer *KafkaSpecZookeeperTemplateZookeeperContainer `json:"zookeeperContainer,omitempty"`
}

// Template for ZooKeeper client `Service`.
type KafkaSpecZookeeperTemplateClientService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplateClientServiceMetadata `json:"metadata,omitempty"`
}

type KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem string

const KafkaSpecZookeeperTemplateClientServiceIpFamiliesElemIPv4 KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem = "IPv4"
const KafkaSpecZookeeperTemplateClientServiceIpFamiliesElemIPv6 KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem = "IPv6"

type KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy string

const KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicyPreferDualStack KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy = "PreferDualStack"
const KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicyRequireDualStack KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy = "RequireDualStack"
const KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicySingleStack KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy = "SingleStack"

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplateClientServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateClientServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateClientServiceMetadataLabels map[string]interface{}

// Template for Secret of the Zookeeper Cluster JMX authentication.
type KafkaSpecZookeeperTemplateJmxSecret struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplateJmxSecretMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplateJmxSecretMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateJmxSecretMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateJmxSecretMetadataLabels map[string]interface{}

// Template for ZooKeeper nodes `Service`.
type KafkaSpecZookeeperTemplateNodesService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplateNodesServiceMetadata `json:"metadata,omitempty"`
}

type KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem string

const KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElemIPv4 KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem = "IPv4"
const KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElemIPv6 KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem = "IPv6"

type KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy string

const KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicyPreferDualStack KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy = "PreferDualStack"
const KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicyRequireDualStack KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy = "RequireDualStack"
const KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicySingleStack KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy = "SingleStack"

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplateNodesServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateNodesServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateNodesServiceMetadataLabels map[string]interface{}

// Template for all ZooKeeper `PersistentVolumeClaims`.
type KafkaSpecZookeeperTemplatePersistentVolumeClaim struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataLabels map[string]interface{}

// Template for ZooKeeper `Pods`.
type KafkaSpecZookeeperTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaSpecZookeeperTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaSpecZookeeperTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaSpecZookeeperTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaSpecZookeeperTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaSpecZookeeperTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// The pod's affinity rules.
type KafkaSpecZookeeperTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaSpecZookeeperTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaSpecZookeeperTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

// Template for ZooKeeper `PodDisruptionBudget`.
type KafkaSpecZookeeperTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
	Metadata *KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty"`
}

// Metadata to apply to the `PodDistruptionBugetTemplate` resource.
type KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataLabels map[string]interface{}

type KafkaSpecZookeeperTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaSpecZookeeperTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplatePodMetadataLabels map[string]interface{}

// Configures pod-level security attributes and common container settings.
type KafkaSpecZookeeperTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaSpecZookeeperTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecZookeeperTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaSpecZookeeperTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

type KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

// Template for the ZooKeeper service account.
type KafkaSpecZookeeperTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateServiceAccountMetadataLabels map[string]interface{}

// Template for ZooKeeper `StatefulSet`.
type KafkaSpecZookeeperTemplateStatefulset struct {
	// Metadata applied to the resource.
	Metadata *KafkaSpecZookeeperTemplateStatefulsetMetadata `json:"metadata,omitempty"`

	// PodManagementPolicy which will be used for this StatefulSet. Valid values are
	// `Parallel` and `OrderedReady`. Defaults to `Parallel`.
	PodManagementPolicy *KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy `json:"podManagementPolicy,omitempty"`
}

// Metadata applied to the resource.
type KafkaSpecZookeeperTemplateStatefulsetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateStatefulsetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaSpecZookeeperTemplateStatefulsetMetadataLabels map[string]interface{}

type KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy string

const KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicyOrderedReady KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy = "OrderedReady"
const KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicyParallel KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy = "Parallel"

// Template for the ZooKeeper container.
type KafkaSpecZookeeperTemplateZookeeperContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaSpecZookeeperTemplateZookeeperContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaSpecZookeeperTemplateZookeeperContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// The status of the Kafka and ZooKeeper clusters, and Topic Operator.
type KafkaStatus struct {
	// Kafka cluster Id.
	ClusterId *string `json:"clusterId,omitempty"`

	// List of status conditions.
	Conditions []KafkaStatusConditionsElem `json:"conditions,omitempty"`

	// Addresses of the internal and external listeners.
	Listeners []KafkaStatusListenersElem `json:"listeners,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty"`
}

type KafkaStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty"`
}

type KafkaStatusListenersElem struct {
	// A list of the addresses for this listener.
	Addresses []KafkaStatusListenersElemAddressesElem `json:"addresses,omitempty"`

	// A comma-separated list of `host:port` pairs for connecting to the Kafka cluster
	// using this listener.
	BootstrapServers *string `json:"bootstrapServers,omitempty"`

	// A list of TLS certificates which can be used to verify the identity of the
	// server when connecting to the given listener. Set only for `tls` and `external`
	// listeners.
	Certificates []string `json:"certificates,omitempty"`

	// The type of the listener. Can be one of the following three types: `plain`,
	// `tls`, and `external`.
	Type *string `json:"type,omitempty"`
}

type KafkaStatusListenersElemAddressesElem struct {
	// The DNS name or IP address of the Kafka bootstrap service.
	Host *string `json:"host,omitempty"`

	// The port of the Kafka bootstrap service.
	Port *int32 `json:"port,omitempty"`
}

var enumValues_KafkaSpecClientsCaCertificateExpirationPolicy = []interface{}{
	"renew-certificate",
	"replace-key",
}
var enumValues_KafkaSpecClusterCaCertificateExpirationPolicy = []interface{}{
	"renew-certificate",
	"replace-key",
}
var enumValues_KafkaSpecCruiseControlLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaSpecCruiseControlMetricsConfigType = []interface{}{
	"jmxPrometheusExporter",
}
var enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecCruiseControlTlsSidecarLogLevel = []interface{}{
	"emerg",
	"alert",
	"crit",
	"err",
	"warning",
	"notice",
	"info",
	"debug",
}
var enumValues_KafkaSpecEntityOperatorTlsSidecarLogLevel = []interface{}{
	"emerg",
	"alert",
	"crit",
	"err",
	"warning",
	"notice",
	"info",
	"debug",
}
var enumValues_KafkaSpecEntityOperatorTopicOperatorLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaSpecEntityOperatorUserOperatorLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaSpecKafkaAuthorizationType = []interface{}{
	"simple",
	"opa",
	"keycloak",
	"custom",
}
var enumValues_KafkaSpecKafkaJmxOptionsAuthenticationType = []interface{}{
	"password",
}
var enumValues_KafkaSpecKafkaListenersElemAuthenticationType = []interface{}{
	"tls",
	"scram-sha-512",
	"oauth",
}
var enumValues_KafkaSpecKafkaListenersElemConfigurationExternalTrafficPolicy = []interface{}{
	"Local",
	"Cluster",
}
var enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecKafkaListenersElemConfigurationIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecKafkaListenersElemConfigurationPreferredNodePortAddressType = []interface{}{
	"ExternalIP",
	"ExternalDNS",
	"InternalIP",
	"InternalDNS",
	"Hostname",
}
var enumValues_KafkaSpecKafkaListenersElemType = []interface{}{
	"internal",
	"route",
	"loadbalancer",
	"nodeport",
	"ingress",
}
var enumValues_KafkaSpecKafkaLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaSpecKafkaMetricsConfigType = []interface{}{
	"jmxPrometheusExporter",
}
var enumValues_KafkaSpecKafkaStorageType = []interface{}{
	"ephemeral",
	"persistent-claim",
	"jbod",
}
var enumValues_KafkaSpecKafkaStorageVolumesElemType = []interface{}{
	"ephemeral",
	"persistent-claim",
}
var enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy = []interface{}{
	"OrderedReady",
	"Parallel",
}
var enumValues_KafkaSpecZookeeperJmxOptionsAuthenticationType = []interface{}{
	"password",
}
var enumValues_KafkaSpecZookeeperLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaSpecZookeeperMetricsConfigType = []interface{}{
	"jmxPrometheusExporter",
}
var enumValues_KafkaSpecZookeeperStorageType = []interface{}{
	"ephemeral",
	"persistent-claim",
}
var enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy = []interface{}{
	"OrderedReady",
	"Parallel",
}
