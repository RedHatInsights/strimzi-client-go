// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1beta2

import "fmt"
import "encoding/json"
import "reflect"

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
import apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecMetricsConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom: required")
	}
	type Plain KafkaConnectSpecMetricsConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecMetricsConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationAccessToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationAccessToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationAccessToken(plain)
	return nil
}

// Reference to the `Secret` which holds the certificate and private key pair.
type KafkaConnectSpecAuthenticationCertificateAndKey struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the private key in the Secret.
	Key string `json:"key"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationCertificateAndKey) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationCertificateAndKey
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationCertificateAndKey(plain)
	return nil
}

// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
// client can use to authenticate against the OAuth server and use the token
// endpoint URI.
type KafkaConnectSpecAuthenticationClientSecret struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationClientSecret) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationClientSecret
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationClientSecret(plain)
	return nil
}

// Reference to the `Secret` which holds the password.
type KafkaConnectSpecAuthenticationPasswordSecret struct {
	// The name of the key in the Secret under which the password is stored.
	Password string `json:"password"`

	// The name of the Secret containing the password.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationPasswordSecret) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationPasswordSecret
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationPasswordSecret(plain)
	return nil
}

// Link to Kubernetes Secret containing the refresh token which can be used to
// obtain access token from the authorization server.
type KafkaConnectSpecAuthenticationRefreshToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationRefreshToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationRefreshToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationRefreshToken(plain)
	return nil
}

type KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem(plain)
	return nil
}

type KafkaConnectSpecAuthenticationType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bootstrapServers"]; !ok || v == nil {
		return fmt.Errorf("field bootstrapServers: required")
	}
	type Plain KafkaConnectSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpec(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecAuthenticationType, v)
	}
	*j = KafkaConnectSpecAuthenticationType(v)
	return nil
}

const KafkaConnectSpecAuthenticationTypeTls KafkaConnectSpecAuthenticationType = "tls"
const KafkaConnectSpecAuthenticationTypeScramSha256 KafkaConnectSpecAuthenticationType = "scram-sha-256"
const KafkaConnectSpecAuthenticationTypeScramSha512 KafkaConnectSpecAuthenticationType = "scram-sha-512"

// Link to Kubernetes Secret containing the access token which was obtained from
// the authorization server.
type KafkaConnectSpecAuthenticationAccessToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName"`
}

const KafkaConnectSpecAuthenticationTypeOauth KafkaConnectSpecAuthenticationType = "oauth"

// Authentication configuration for Kafka Connect.
type KafkaConnectSpecAuthentication struct {
	// Link to Kubernetes Secret containing the access token which was obtained from
	// the authorization server.
	AccessToken *KafkaConnectSpecAuthenticationAccessToken `json:"accessToken,omitempty"`

	// Configure whether access token should be treated as JWT. This should be set to
	// `false` if the authorization server returns opaque tokens. Defaults to `true`.
	AccessTokenIsJwt *bool `json:"accessTokenIsJwt,omitempty"`

	// OAuth audience to use when authenticating against the authorization server.
	// Some authorization servers require the audience to be explicitly set. The
	// possible values depend on how the authorization server is configured. By
	// default, `audience` is not specified when performing the token endpoint
	// request.
	Audience *string `json:"audience,omitempty"`

	// Reference to the `Secret` which holds the certificate and private key pair.
	CertificateAndKey *KafkaConnectSpecAuthenticationCertificateAndKey `json:"certificateAndKey,omitempty"`

	// OAuth Client ID which the Kafka client can use to authenticate against the
	// OAuth server and use the token endpoint URI.
	ClientId *string `json:"clientId,omitempty"`

	// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
	// client can use to authenticate against the OAuth server and use the token
	// endpoint URI.
	ClientSecret *KafkaConnectSpecAuthenticationClientSecret `json:"clientSecret,omitempty"`

	// The connect timeout in seconds when connecting to authorization server. If not
	// set, the effective connect timeout is 60 seconds.
	ConnectTimeoutSeconds *int32 `json:"connectTimeoutSeconds,omitempty"`

	// Enable or disable TLS hostname verification. Default value is `false`.
	DisableTlsHostnameVerification *bool `json:"disableTlsHostnameVerification,omitempty"`

	// Set or limit time-to-live of the access tokens to the specified number of
	// seconds. This should be set if the authorization server returns opaque tokens.
	MaxTokenExpirySeconds *int32 `json:"maxTokenExpirySeconds,omitempty"`

	// Reference to the `Secret` which holds the password.
	PasswordSecret *KafkaConnectSpecAuthenticationPasswordSecret `json:"passwordSecret,omitempty"`

	// The read timeout in seconds when connecting to authorization server. If not
	// set, the effective read timeout is 60 seconds.
	ReadTimeoutSeconds *int32 `json:"readTimeoutSeconds,omitempty"`

	// Link to Kubernetes Secret containing the refresh token which can be used to
	// obtain access token from the authorization server.
	RefreshToken *KafkaConnectSpecAuthenticationRefreshToken `json:"refreshToken,omitempty"`

	// OAuth scope to use when authenticating against the authorization server. Some
	// authorization servers require this to be set. The possible values depend on how
	// authorization server is configured. By default `scope` is not specified when
	// doing the token endpoint request.
	Scope *string `json:"scope,omitempty"`

	// Trusted certificates for TLS connection to the OAuth server.
	TlsTrustedCertificates []KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem `json:"tlsTrustedCertificates,omitempty"`

	// Authorization server token endpoint URI.
	TokenEndpointUri *string `json:"tokenEndpointUri,omitempty"`

	// Authentication type. Currently the only supported types are `tls`,
	// `scram-sha-256`, `scram-sha-512`, and `plain`. `scram-sha-256` and
	// `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512
	// Authentication, respectively. `plain` type uses SASL PLAIN Authentication.
	// `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS
	// Client Authentication. The `tls` type is supported only over TLS connections.
	Type KafkaConnectSpecAuthenticationType `json:"type"`

	// Username used for the authentication.
	Username *string `json:"username,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthentication(plain)
	return nil
}

type KafkaConnectSpecBuildOutputType string

// The specification of the Kafka Connect cluster.
type KafkaConnectSpec struct {
	// Authentication configuration for Kafka Connect.
	Authentication *KafkaConnectSpecAuthentication `json:"authentication,omitempty"`

	// Bootstrap servers to connect to. This should be given as a comma separated list
	// of _<hostname>_:_<port>_ pairs.
	BootstrapServers string `json:"bootstrapServers"`

	// Configures how the Connect container image should be built. Optional.
	Build *KafkaConnectSpecBuild `json:"build,omitempty"`

	// The image of the init container used for initializing the `client.rack`.
	ClientRackInitImage *string `json:"clientRackInitImage,omitempty"`

	// The Kafka Connect configuration. Properties with the following prefixes cannot
	// be set: ssl., sasl., security., listeners, plugin.path, rest.,
	// bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes
	// (with the exception of: ssl.endpoint.identification.algorithm,
	// ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
	Config *apiextensions.JSON `json:"config,omitempty"`

	// Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to
	// configure connectors.
	ExternalConfiguration *KafkaConnectSpecExternalConfiguration `json:"externalConfiguration,omitempty"`

	// The docker image for the pods.
	Image *string `json:"image,omitempty"`

	// JMX Options.
	JmxOptions *KafkaConnectSpecJmxOptions `json:"jmxOptions,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaConnectSpecJvmOptions `json:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaConnectSpecLivenessProbe `json:"livenessProbe,omitempty"`

	// Logging configuration for Kafka Connect.
	Logging *KafkaConnectSpecLogging `json:"logging,omitempty"`

	// Metrics configuration.
	MetricsConfig *KafkaConnectSpecMetricsConfig `json:"metricsConfig,omitempty"`

	// Configuration of the node label which will be used as the client.rack consumer
	// configuration.
	Rack *KafkaConnectSpecRack `json:"rack,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaConnectSpecReadinessProbe `json:"readinessProbe,omitempty"`

	// The number of pods in the Kafka Connect group.
	Replicas *int32 `json:"replicas,omitempty"`

	// The maximum limits for CPU and memory resources and the requested initial
	// resources.
	Resources *KafkaConnectSpecResources `json:"resources,omitempty"`

	// Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template
	// allows users to specify how the `Deployment`, `Pods` and `Service` are
	// generated.
	Template *KafkaConnectSpecTemplate `json:"template,omitempty"`

	// TLS configuration.
	Tls *KafkaConnectSpecTls `json:"tls,omitempty"`

	// The configuration of tracing in Kafka Connect.
	Tracing *KafkaConnectSpecTracing `json:"tracing,omitempty"`

	// The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user
	// documentation to understand the process required to upgrade or downgrade the
	// version.
	Version *string `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildOutputType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecBuildOutputType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecBuildOutputType, v)
	}
	*j = KafkaConnectSpecBuildOutputType(v)
	return nil
}

const KafkaConnectSpecBuildOutputTypeDocker KafkaConnectSpecBuildOutputType = "docker"
const KafkaConnectSpecBuildOutputTypeImagestream KafkaConnectSpecBuildOutputType = "imagestream"

// Configures where should the newly built image be stored. Required.
type KafkaConnectSpecBuildOutput struct {
	// Configures additional options which will be passed to the Kaniko executor when
	// building the new Connect image. Allowed options are: --customPlatform,
	// --insecure, --insecure-pull, --insecure-registry, --log-format,
	// --log-timestamp, --registry-mirror, --reproducible, --single-snapshot,
	// --skip-tls-verify, --skip-tls-verify-pull, --skip-tls-verify-registry,
	// --verbosity, --snapshotMode, --use-new-run. These options will be used only on
	// Kubernetes where the Kaniko executor is used. They will be ignored on
	// OpenShift. The options are described in the
	// link:https://github.com/GoogleContainerTools/kaniko[Kaniko GitHub repository^].
	// Changing this field does not trigger new build of the Kafka Connect image.
	AdditionalKanikoOptions []string `json:"additionalKanikoOptions,omitempty"`

	// The name of the image which will be built. Required.
	Image string `json:"image"`

	// Container Registry Secret with the credentials for pushing the newly built
	// image.
	PushSecret *string `json:"pushSecret,omitempty"`

	// Output type. Must be either `docker` for pushing the newly build image to
	// Docker compatible registry or `imagestream` for pushing the image to OpenShift
	// ImageStream. Required.
	Type KafkaConnectSpecBuildOutputType `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["image"]; !ok || v == nil {
		return fmt.Errorf("field image: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecBuildOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuildOutput(plain)
	return nil
}

type KafkaConnectSpecBuildPluginsElemArtifactsElemType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTracing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecTracing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecTracing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElemArtifactsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType, v)
	}
	*j = KafkaConnectSpecBuildPluginsElemArtifactsElemType(v)
	return nil
}

const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeJar KafkaConnectSpecBuildPluginsElemArtifactsElemType = "jar"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeTgz KafkaConnectSpecBuildPluginsElemArtifactsElemType = "tgz"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeZip KafkaConnectSpecBuildPluginsElemArtifactsElemType = "zip"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeMaven KafkaConnectSpecBuildPluginsElemArtifactsElemType = "maven"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeOther KafkaConnectSpecBuildPluginsElemArtifactsElemType = "other"

type KafkaConnectSpecBuildPluginsElemArtifactsElem struct {
	// Maven artifact id. Applicable to the `maven` artifact type only.
	Artifact *string `json:"artifact,omitempty"`

	// Name under which the artifact will be stored.
	FileName *string `json:"fileName,omitempty"`

	// Maven group id. Applicable to the `maven` artifact type only.
	Group *string `json:"group,omitempty"`

	// By default, connections using TLS are verified to check they are secure. The
	// server certificate used must be valid, trusted, and contain the server name. By
	// setting this option to `true`, all TLS verification is disabled and the
	// artifact will be downloaded, even when the server is considered insecure.
	Insecure *bool `json:"insecure,omitempty"`

	// Maven repository to download the artifact from. Applicable to the `maven`
	// artifact type only.
	Repository *string `json:"repository,omitempty"`

	// SHA512 checksum of the artifact. Optional. If specified, the checksum will be
	// verified while building the new container. If not specified, the downloaded
	// artifact will not be verified. Not applicable to the `maven` artifact type.
	Sha512Sum *string `json:"sha512sum,omitempty"`

	// Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`,
	// `other` and `maven`.
	Type KafkaConnectSpecBuildPluginsElemArtifactsElemType `json:"type"`

	// URL of the artifact which will be downloaded. Strimzi does not do any security
	// scanning of the downloaded artifacts. For security reasons, you should first
	// verify the artifacts manually and configure the checksum verification to make
	// sure the same artifact is used in the automated build. Required for `jar`,
	// `zip`, `tgz` and `other` artifacts. Not applicable to the `maven` artifact
	// type.
	Url *string `json:"url,omitempty"`

	// Maven version number. Applicable to the `maven` artifact type only.
	Version *string `json:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElemArtifactsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecBuildPluginsElemArtifactsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuildPluginsElemArtifactsElem(plain)
	return nil
}

type KafkaConnectSpecBuildPluginsElem struct {
	// List of artifacts which belong to this connector plugin. Required.
	Artifacts []KafkaConnectSpecBuildPluginsElemArtifactsElem `json:"artifacts"`

	// The unique name of the connector plugin. Will be used to generate the path
	// where the connector artifacts will be stored. The name has to be unique within
	// the KafkaConnect resource. The name has to follow the following pattern:
	// `^[a-z][-_a-z0-9]*[a-z]$`. Required.
	Name string `json:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["artifacts"]; !ok || v == nil {
		return fmt.Errorf("field artifacts: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain KafkaConnectSpecBuildPluginsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuildPluginsElem(plain)
	return nil
}

//type KafkaConnectSpecBuildResourcesLimits map[string]interface{}

//type KafkaConnectSpecBuildResourcesRequests map[string]interface{}

// CPU and memory resources to reserve for the build.
type KafkaConnectSpecBuildResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

// Configures how the Connect container image should be built. Optional.
type KafkaConnectSpecBuild struct {
	// Configures where should the newly built image be stored. Required.
	Output KafkaConnectSpecBuildOutput `json:"output"`

	// List of connector plugins which should be added to the Kafka Connect. Required.
	Plugins []KafkaConnectSpecBuildPluginsElem `json:"plugins"`

	// CPU and memory resources to reserve for the build.
	Resources *KafkaConnectSpecBuildResources `json:"resources,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuild) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["output"]; !ok || v == nil {
		return fmt.Errorf("field output: required")
	}
	if v, ok := raw["plugins"]; !ok || v == nil {
		return fmt.Errorf("field plugins: required")
	}
	type Plain KafkaConnectSpecBuild
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuild(plain)
	return nil
}

// The Kafka Connect configuration. Properties with the following prefixes cannot
// be set: ssl., sasl., security., listeners, plugin.path, rest.,
// bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes
// (with the exception of: ssl.endpoint.identification.algorithm,
// ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
//type KafkaConnectSpecConfig map[string]interface{}

// Reference to a key in a ConfigMap.
type KafkaConnectSpecExternalConfigurationEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Reference to a key in a Secret.
type KafkaConnectSpecExternalConfigurationEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Value of the environment variable which will be passed to the Kafka Connect
// pods. It can be passed either as a reference to Secret or ConfigMap field. The
// field has to specify exactly one Secret or ConfigMap.
type KafkaConnectSpecExternalConfigurationEnvElemValueFrom struct {
	// Reference to a key in a ConfigMap.
	ConfigMapKeyRef *KafkaConnectSpecExternalConfigurationEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`

	// Reference to a key in a Secret.
	SecretKeyRef *KafkaConnectSpecExternalConfigurationEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty"`
}

type KafkaConnectSpecExternalConfigurationEnvElem struct {
	// Name of the environment variable which will be passed to the Kafka Connect
	// pods. The name of the environment variable cannot start with `KAFKA_` or
	// `STRIMZI_`.
	Name string `json:"name"`

	// Value of the environment variable which will be passed to the Kafka Connect
	// pods. It can be passed either as a reference to Secret or ConfigMap field. The
	// field has to specify exactly one Secret or ConfigMap.
	ValueFrom KafkaConnectSpecExternalConfigurationEnvElemValueFrom `json:"valueFrom"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecExternalConfigurationEnvElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom: required")
	}
	type Plain KafkaConnectSpecExternalConfigurationEnvElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecExternalConfigurationEnvElem(plain)
	return nil
}

type KafkaConnectSpecExternalConfigurationVolumesElemConfigMapItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty"`
}

// Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be
// specified.
type KafkaConnectSpecExternalConfigurationVolumesElemConfigMap struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecExternalConfigurationVolumesElemConfigMapItemsElem `json:"items,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

type KafkaConnectSpecExternalConfigurationVolumesElemSecretItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty"`
}

// Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be
// specified.
type KafkaConnectSpecExternalConfigurationVolumesElemSecret struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecExternalConfigurationVolumesElemSecretItemsElem `json:"items,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`

	// SecretName corresponds to the JSON schema field "secretName".
	SecretName *string `json:"secretName,omitempty"`
}

type KafkaConnectSpecExternalConfigurationVolumesElem struct {
	// Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be
	// specified.
	ConfigMap *KafkaConnectSpecExternalConfigurationVolumesElemConfigMap `json:"configMap,omitempty"`

	// Name of the volume which will be added to the Kafka Connect pods.
	Name string `json:"name"`

	// Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be
	// specified.
	Secret *KafkaConnectSpecExternalConfigurationVolumesElemSecret `json:"secret,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecExternalConfigurationVolumesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain KafkaConnectSpecExternalConfigurationVolumesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecExternalConfigurationVolumesElem(plain)
	return nil
}

// Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to
// configure connectors.
type KafkaConnectSpecExternalConfiguration struct {
	// Makes data from a Secret or ConfigMap available in the Kafka Connect pods as
	// environment variables.
	Env []KafkaConnectSpecExternalConfigurationEnvElem `json:"env,omitempty"`

	// Makes data from a Secret or ConfigMap available in the Kafka Connect pods as
	// volumes.
	Volumes []KafkaConnectSpecExternalConfigurationVolumesElem `json:"volumes,omitempty"`
}

type KafkaConnectSpecJmxOptionsAuthenticationType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTracingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTracingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTracingType, v)
	}
	*j = KafkaConnectSpecTracingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecJmxOptionsAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecJmxOptionsAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecJmxOptionsAuthenticationType, v)
	}
	*j = KafkaConnectSpecJmxOptionsAuthenticationType(v)
	return nil
}

const KafkaConnectSpecJmxOptionsAuthenticationTypePassword KafkaConnectSpecJmxOptionsAuthenticationType = "password"

// Authentication configuration for connecting to the JMX port.
type KafkaConnectSpecJmxOptionsAuthentication struct {
	// Authentication type. Currently the only supported types are
	// `password`.`password` type creates a username and protected port with no TLS.
	Type KafkaConnectSpecJmxOptionsAuthenticationType `json:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecJmxOptionsAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecJmxOptionsAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecJmxOptionsAuthentication(plain)
	return nil
}

// JMX Options.
type KafkaConnectSpecJmxOptions struct {
	// Authentication configuration for connecting to the JMX port.
	Authentication *KafkaConnectSpecJmxOptionsAuthentication `json:"authentication,omitempty"`
}

// A map of -XX options to the JVM.
//type KafkaConnectSpecJvmOptionsXX map[string]interface{}

type KafkaConnectSpecJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty"`
}

// JVM Options for pods.
type KafkaConnectSpecJvmOptions struct {
	// A map of -XX options to the JVM.
	XX *apiextensions.JSON `json:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaConnectSpecJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty"`
}

// Pod liveness checking.
type KafkaConnectSpecLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// A Map from logger name to logger level.
//type KafkaConnectSpecLoggingLoggers map[string]interface{}

type KafkaConnectSpecLoggingType string

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTlsTrustedCertificatesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["certificate"]; !ok || v == nil {
		return fmt.Errorf("field certificate: required")
	}
	if v, ok := raw["secretName"]; !ok || v == nil {
		return fmt.Errorf("field secretName: required")
	}
	type Plain KafkaConnectSpecTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecTlsTrustedCertificatesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecLoggingType, v)
	}
	*j = KafkaConnectSpecLoggingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateApiServiceIpFamilyPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy, v)
	}
	*j = KafkaConnectSpecTemplateApiServiceIpFamilyPolicy(v)
	return nil
}

const KafkaConnectSpecAuthenticationTypePlain KafkaConnectSpecAuthenticationType = "plain"

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateDeploymentDeploymentStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy, v)
	}
	*j = KafkaConnectSpecTemplateDeploymentDeploymentStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateApiServiceIpFamiliesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem, v)
	}
	*j = KafkaConnectSpecTemplateApiServiceIpFamiliesElem(v)
	return nil
}

// Logging configuration for Kafka Connect.
type KafkaConnectSpecLogging struct {
	// A Map from logger name to logger level.
	Loggers *apiextensions.JSON `json:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaConnectSpecLoggingType `json:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaConnectSpecLoggingValueFrom `json:"valueFrom,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain KafkaConnectSpecLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecLogging(plain)
	return nil
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// KafkaConnect
type KafkaConnect struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the Kafka Connect cluster.
	Spec *KafkaConnectSpec `json:"spec,omitempty"`

	// The status of the Kafka Connect cluster.
	Status *KafkaConnectStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaConnectList contains a list of instances.
type KafkaConnectList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of Kafka objects.
	Items []KafkaConnect `json:"items,omitempty"`
}

func init() {
	SchemeBuilder.Register(&KafkaConnect{}, &KafkaConnectList{})
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecRack) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["topologyKey"]; !ok || v == nil {
		return fmt.Errorf("field topologyKey: required")
	}
	type Plain KafkaConnectSpecRack
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecRack(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecMetricsConfigType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecMetricsConfigType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecMetricsConfigType, v)
	}
	*j = KafkaConnectSpecMetricsConfigType(v)
	return nil
}

const KafkaConnectSpecLoggingTypeExternal KafkaConnectSpecLoggingType = "external"
const KafkaConnectSpecLoggingTypeInline KafkaConnectSpecLoggingType = "inline"

// `ConfigMap` entry where the logging configuration is stored.
type KafkaConnectSpecLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaConnectSpecLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaConnectSpecLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Metrics configuration.
type KafkaConnectSpecMetricsConfig struct {
	// Metrics type. Only 'jmxPrometheusExporter' supported currently.
	Type KafkaConnectSpecMetricsConfigType `json:"type"`

	// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
	// details of the structure of this configuration, see the {JMXExporter}.
	ValueFrom KafkaConnectSpecMetricsConfigValueFrom `json:"valueFrom"`
}

type KafkaConnectSpecMetricsConfigType string

const KafkaConnectSpecMetricsConfigTypeJmxPrometheusExporter KafkaConnectSpecMetricsConfigType = "jmxPrometheusExporter"

// ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For
// details of the structure of this configuration, see the {JMXExporter}.
type KafkaConnectSpecMetricsConfigValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
type KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty"`
}

// Configuration of the node label which will be used as the client.rack consumer
// configuration.
type KafkaConnectSpecRack struct {
	// A key that matches labels assigned to the Kubernetes cluster nodes. The value
	// of the label is used to set the broker's `broker.rack` config and `client.rack`
	// in Kafka Connect.
	TopologyKey string `json:"topologyKey"`
}

// Pod readiness checking.
type KafkaConnectSpecReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty"`
}

// The maximum limits for CPU and memory resources and the requested initial
// resources.
type KafkaConnectSpecResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty"`
}

//type KafkaConnectSpecResourcesLimits map[string]interface{}

//type KafkaConnectSpecResourcesRequests map[string]interface{}

// Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template
// allows users to specify how the `Deployment`, `Pods` and `Service` are
// generated.
type KafkaConnectSpecTemplate struct {
	// Template for Kafka Connect API `Service`.
	ApiService *KafkaConnectSpecTemplateApiService `json:"apiService,omitempty"`

	// Template for the Kafka Connect BuildConfig used to build new container images.
	// The BuildConfig is used only on OpenShift.
	BuildConfig *KafkaConnectSpecTemplateBuildConfig `json:"buildConfig,omitempty"`

	// Template for the Kafka Connect Build container. The build container is used
	// only on Kubernetes.
	BuildContainer *KafkaConnectSpecTemplateBuildContainer `json:"buildContainer,omitempty"`

	// Template for Kafka Connect Build `Pods`. The build pod is used only on
	// Kubernetes.
	BuildPod *KafkaConnectSpecTemplateBuildPod `json:"buildPod,omitempty"`

	// Template for the Kafka Connect Build service account.
	BuildServiceAccount *KafkaConnectSpecTemplateBuildServiceAccount `json:"buildServiceAccount,omitempty"`

	// Template for the Kafka Connect ClusterRoleBinding.
	ClusterRoleBinding *KafkaConnectSpecTemplateClusterRoleBinding `json:"clusterRoleBinding,omitempty"`

	// Template for the Kafka Connect container.
	ConnectContainer *KafkaConnectSpecTemplateConnectContainer `json:"connectContainer,omitempty"`

	// Template for Kafka Connect `Deployment`.
	Deployment *KafkaConnectSpecTemplateDeployment `json:"deployment,omitempty"`

	// Template for the Kafka init container.
	InitContainer *KafkaConnectSpecTemplateInitContainer `json:"initContainer,omitempty"`

	// Template for Secret of the Kafka Connect Cluster JMX authentication.
	JmxSecret *KafkaConnectSpecTemplateJmxSecret `json:"jmxSecret,omitempty"`

	// Template for Kafka Connect `Pods`.
	Pod *KafkaConnectSpecTemplatePod `json:"pod,omitempty"`

	// Template for Kafka Connect `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaConnectSpecTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty"`

	// Template for the Kafka Connect service account.
	ServiceAccount *KafkaConnectSpecTemplateServiceAccount `json:"serviceAccount,omitempty"`
}

// Template for Kafka Connect API `Service`.
type KafkaConnectSpecTemplateApiService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
	IpFamilies []KafkaConnectSpecTemplateApiServiceIpFamiliesElem `json:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type. Available on Kubernetes 1.20 and newer.
	IpFamilyPolicy *KafkaConnectSpecTemplateApiServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateApiServiceMetadata `json:"metadata,omitempty"`
}

type KafkaConnectSpecTemplateApiServiceIpFamiliesElem string

const KafkaConnectSpecTemplateApiServiceIpFamiliesElemIPv4 KafkaConnectSpecTemplateApiServiceIpFamiliesElem = "IPv4"
const KafkaConnectSpecTemplateApiServiceIpFamiliesElemIPv6 KafkaConnectSpecTemplateApiServiceIpFamiliesElem = "IPv6"

type KafkaConnectSpecTemplateApiServiceIpFamilyPolicy string

const KafkaConnectSpecTemplateApiServiceIpFamilyPolicyPreferDualStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "PreferDualStack"
const KafkaConnectSpecTemplateApiServiceIpFamilyPolicyRequireDualStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "RequireDualStack"
const KafkaConnectSpecTemplateApiServiceIpFamilyPolicySingleStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "SingleStack"

// Metadata applied to the resource.
type KafkaConnectSpecTemplateApiServiceMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateApiServiceMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateApiServiceMetadataLabels map[string]interface{}

// Template for the Kafka Connect BuildConfig used to build new container images.
// The BuildConfig is used only on OpenShift.
type KafkaConnectSpecTemplateBuildConfig struct {
	// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
	Metadata *KafkaConnectSpecTemplateBuildConfigMetadata `json:"metadata,omitempty"`

	// Container Registry Secret with the credentials for pulling the base image.
	PullSecret *string `json:"pullSecret,omitempty"`
}

// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
type KafkaConnectSpecTemplateBuildConfigMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildConfigMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildConfigMetadataLabels map[string]interface{}

// Template for the Kafka Connect Build container. The build container is used only
// on Kubernetes.
type KafkaConnectSpecTemplateBuildContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateBuildContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateBuildContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaConnectSpecTemplateBuildContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaConnectSpecTemplateBuildContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Template for Kafka Connect Build `Pods`. The build pod is used only on
// Kubernetes.
type KafkaConnectSpecTemplateBuildPod struct {
	// The pod's affinity rules.
	Affinity *KafkaConnectSpecTemplateBuildPodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaConnectSpecTemplateBuildPodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaConnectSpecTemplateBuildPodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateBuildPodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaConnectSpecTemplateBuildPodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaConnectSpecTemplateBuildPodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// The pod's affinity rules.
type KafkaConnectSpecTemplateBuildPodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaConnectSpecTemplateBuildPodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplateBuildPodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplateBuildPodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildPodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildPodMetadataLabels map[string]interface{}

// Configures pod-level security attributes and common container settings.
type KafkaConnectSpecTemplateBuildPodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaConnectSpecTemplateBuildPodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

// Template for the Kafka Connect Build service account.
type KafkaConnectSpecTemplateBuildServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateBuildServiceAccountMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplateBuildServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateBuildServiceAccountMetadataLabels map[string]interface{}

// Template for the Kafka Connect ClusterRoleBinding.
type KafkaConnectSpecTemplateClusterRoleBinding struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateClusterRoleBindingMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplateClusterRoleBindingMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateClusterRoleBindingMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateClusterRoleBindingMetadataLabels map[string]interface{}

// Template for the Kafka Connect container.
type KafkaConnectSpecTemplateConnectContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateConnectContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateConnectContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaConnectSpecTemplateConnectContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaConnectSpecTemplateConnectContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Template for Kafka Connect `Deployment`.
type KafkaConnectSpecTemplateDeployment struct {
	// DeploymentStrategy which will be used for this Deployment. Valid values are
	// `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
	DeploymentStrategy *KafkaConnectSpecTemplateDeploymentDeploymentStrategy `json:"deploymentStrategy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateDeploymentMetadata `json:"metadata,omitempty"`
}

type KafkaConnectSpecTemplateDeploymentDeploymentStrategy string

const KafkaConnectSpecTemplateDeploymentDeploymentStrategyRecreate KafkaConnectSpecTemplateDeploymentDeploymentStrategy = "Recreate"
const KafkaConnectSpecTemplateDeploymentDeploymentStrategyRollingUpdate KafkaConnectSpecTemplateDeploymentDeploymentStrategy = "RollingUpdate"

// Metadata applied to the resource.
type KafkaConnectSpecTemplateDeploymentMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateDeploymentMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateDeploymentMetadataLabels map[string]interface{}

// Template for the Kafka init container.
type KafkaConnectSpecTemplateInitContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateInitContainerEnvElem `json:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateInitContainerSecurityContext `json:"securityContext,omitempty"`
}

type KafkaConnectSpecTemplateInitContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty"`
}

// Security context for the container.
type KafkaConnectSpecTemplateInitContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities `json:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty"`
}

type KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

// Template for Secret of the Kafka Connect Cluster JMX authentication.
type KafkaConnectSpecTemplateJmxSecret struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateJmxSecretMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplateJmxSecretMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateJmxSecretMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateJmxSecretMetadataLabels map[string]interface{}

// Template for Kafka Connect `Pods`.
type KafkaConnectSpecTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaConnectSpecTemplatePodAffinity `json:"affinity,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaConnectSpecTemplatePodHostAliasesElem `json:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaConnectSpecTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplatePodMetadata `json:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods. For more
	// information about priority classes, see {K8sPriorityClass}.
	PriorityClassName *string `json:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaConnectSpecTemplatePodSecurityContext `json:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount (for example `1Gi`) of local storage required for
	// temporary EmptyDir volume (`/tmp`). Default value is `1Mi`.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaConnectSpecTemplatePodTolerationsElem `json:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaConnectSpecTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty"`
}

// The pod's affinity rules.
type KafkaConnectSpecTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaConnectSpecTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaConnectSpecTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaConnectSpecTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchLabels map[string]interface{}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchLabels map[string]interface{}

// Template for Kafka Connect `PodDisruptionBudget`.
type KafkaConnectSpecTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
	Metadata *KafkaConnectSpecTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty"`
}

// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
type KafkaConnectSpecTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplatePodDisruptionBudgetMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplatePodDisruptionBudgetMetadataLabels map[string]interface{}

type KafkaConnectSpecTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty"`
}

type KafkaConnectSpecTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplatePodMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplatePodMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplatePodMetadataLabels map[string]interface{}

// Configures pod-level security attributes and common container settings.
type KafkaConnectSpecTemplatePodSecurityContext struct {
	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaConnectSpecTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty"`
}

type KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

type KafkaConnectSpecTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty"`
}

type KafkaConnectSpecTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaConnectSpecTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty"`
}

type KafkaConnectSpecTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty"`
}

type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty"`
}

type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels *apiextensions.JSON `json:"matchLabels,omitempty"`
}

type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty"`
}

//type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchLabels map[string]interface{}

// Template for the Kafka Connect service account.
type KafkaConnectSpecTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateServiceAccountMetadata `json:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaConnectSpecTemplateServiceAccountMetadata struct {
	// Annotations added to the resource template. Can be applied to different
	// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Annotations *apiextensions.JSON `json:"annotations,omitempty"`

	// Labels added to the resource template. Can be applied to different resources
	// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
	Labels *apiextensions.JSON `json:"labels,omitempty"`
}

// Annotations added to the resource template. Can be applied to different
// resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateServiceAccountMetadataAnnotations map[string]interface{}

// Labels added to the resource template. Can be applied to different resources
// such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
//type KafkaConnectSpecTemplateServiceAccountMetadataLabels map[string]interface{}

// TLS configuration.
type KafkaConnectSpecTls struct {
	// Trusted certificates for TLS connection.
	TrustedCertificates []KafkaConnectSpecTlsTrustedCertificatesElem `json:"trustedCertificates,omitempty"`
}

type KafkaConnectSpecTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName"`
}

// The configuration of tracing in Kafka Connect.
type KafkaConnectSpecTracing struct {
	// Type of the tracing used. Currently the only supported type is `jaeger` for
	// Jaeger tracing.
	Type KafkaConnectSpecTracingType `json:"type"`
}

type KafkaConnectSpecTracingType string

const KafkaConnectSpecTracingTypeJaeger KafkaConnectSpecTracingType = "jaeger"

// The status of the Kafka Connect cluster.
type KafkaConnectStatus struct {
	// List of status conditions.
	Conditions []KafkaConnectStatusConditionsElem `json:"conditions,omitempty"`

	// The list of connector plugins available in this Kafka Connect deployment.
	ConnectorPlugins []KafkaConnectStatusConnectorPluginsElem `json:"connectorPlugins,omitempty"`

	// Label selector for pods providing this resource.
	LabelSelector *string `json:"labelSelector,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty"`

	// The current number of pods being used to provide this resource.
	Replicas *int32 `json:"replicas,omitempty"`

	// The URL of the REST API endpoint for managing and monitoring Kafka Connect
	// connectors.
	Url *string `json:"url,omitempty"`
}

type KafkaConnectStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty"`
}

type KafkaConnectStatusConnectorPluginsElem struct {
	// The class of the connector plugin.
	Class *string `json:"class,omitempty"`

	// The type of the connector plugin. The available types are `sink` and `source`.
	Type *string `json:"type,omitempty"`

	// The version of the connector plugin.
	Version *string `json:"version,omitempty"`
}

var enumValues_KafkaConnectSpecAuthenticationType = []interface{}{
	"tls",
	"scram-sha-256",
	"scram-sha-512",
	"plain",
	"oauth",
}
var enumValues_KafkaConnectSpecBuildOutputType = []interface{}{
	"docker",
	"imagestream",
}
var enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType = []interface{}{
	"jar",
	"tgz",
	"zip",
	"maven",
	"other",
}
var enumValues_KafkaConnectSpecJmxOptionsAuthenticationType = []interface{}{
	"password",
}
var enumValues_KafkaConnectSpecLoggingType = []interface{}{
	"inline",
	"external",
}
var enumValues_KafkaConnectSpecMetricsConfigType = []interface{}{
	"jmxPrometheusExporter",
}
var enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}
var enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}
var enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy = []interface{}{
	"RollingUpdate",
	"Recreate",
}
var enumValues_KafkaConnectSpecTracingType = []interface{}{
	"jaeger",
}
