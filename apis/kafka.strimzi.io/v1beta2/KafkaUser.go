// Code partially generated by github.com/atombender/go-jsonschema

package v1beta2

import (
	"encoding/json"
	"fmt"
	"reflect"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// KafkaUser
type KafkaUser struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the user.
	Spec *KafkaUserSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// The status of the Kafka User.
	Status *KafkaUserStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaUserList contains a list of instances.
type KafkaUserList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of KafkaUser objects.
	Items []KafkaUser `json:"items,omitempty"`
}

// The specification of the user.
type KafkaUserSpec struct {
	// Authentication mechanism enabled for this Kafka user. The supported
	// authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
	//
	// * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
	// * `tls` generates a secret with user certificate for mutual TLS authentication.
	// * `tls-external` does not generate a user certificate.   But prepares the user
	// for using mutual TLS authentication using a user certificate generated outside
	// the User Operator.
	//   ACLs and quotas set for this user are configured in the `CN=<username>`
	// format.
	//
	// Authentication is optional. If authentication is not configured, no credentials
	// are generated. ACLs and quotas set for the user are configured in the
	// `<username>` format suitable for SASL authentication.
	Authentication *KafkaUserSpecAuthentication `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`

	// Authorization rules for this Kafka user.
	Authorization *KafkaUserSpecAuthorization `json:"authorization,omitempty" yaml:"authorization,omitempty" mapstructure:"authorization,omitempty"`

	// Quotas on requests to control the broker resources used by clients. Network
	// bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka
	// User quotas can be found at
	// http://kafka.apache.org/documentation/#design_quotas.
	Quotas *KafkaUserSpecQuotas `json:"quotas,omitempty" yaml:"quotas,omitempty" mapstructure:"quotas,omitempty"`

	// Template to specify how Kafka User `Secrets` are generated.
	Template *KafkaUserSpecTemplate `json:"template,omitempty" yaml:"template,omitempty" mapstructure:"template,omitempty"`
}

// Authentication mechanism enabled for this Kafka user. The supported
// authentication mechanisms are `scram-sha-512`, `tls`, and `tls-external`.
//
// * `scram-sha-512` generates a secret with SASL SCRAM-SHA-512 credentials.
// * `tls` generates a secret with user certificate for mutual TLS authentication.
// * `tls-external` does not generate a user certificate.   But prepares the user
// for using mutual TLS authentication using a user certificate generated outside
// the User Operator.
//
//	ACLs and quotas set for this user are configured in the `CN=<username>`
//
// format.
//
// Authentication is optional. If authentication is not configured, no credentials
// are generated. ACLs and quotas set for the user are configured in the
// `<username>` format suitable for SASL authentication.
type KafkaUserSpecAuthentication struct {
	// Specify the password for the user. If not set, a new password is generated by
	// the User Operator.
	Password *KafkaUserSpecAuthenticationPassword `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Authentication type.
	Type KafkaUserSpecAuthenticationType `json:"type" yaml:"type" mapstructure:"type"`
}

// Specify the password for the user. If not set, a new password is generated by
// the User Operator.
type KafkaUserSpecAuthenticationPassword struct {
	// Secret from which the password should be read.
	ValueFrom KafkaUserSpecAuthenticationPasswordValueFrom `json:"valueFrom" yaml:"valueFrom" mapstructure:"valueFrom"`
}

// Secret from which the password should be read.
type KafkaUserSpecAuthenticationPasswordValueFrom struct {
	// Selects a key of a Secret in the resource's namespace.
	SecretKeyRef *KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Selects a key of a Secret in the resource's namespace.
type KafkaUserSpecAuthenticationPasswordValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

type KafkaUserSpecAuthenticationType string

const KafkaUserSpecAuthenticationTypeScramSha512 KafkaUserSpecAuthenticationType = "scram-sha-512"
const KafkaUserSpecAuthenticationTypeTls KafkaUserSpecAuthenticationType = "tls"
const KafkaUserSpecAuthenticationTypeTlsExternal KafkaUserSpecAuthenticationType = "tls-external"

// Authorization rules for this Kafka user.
type KafkaUserSpecAuthorization struct {
	// List of ACL rules which should be applied to this user.
	Acls []KafkaUserSpecAuthorizationAclsElem `json:"acls" yaml:"acls" mapstructure:"acls"`

	// Authorization type. Currently the only supported type is `simple`. `simple`
	// authorization type uses the Kafka Admin API for managing the ACL rules.
	Type KafkaUserSpecAuthorizationType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaUserSpecAuthorizationAclsElem struct {
	// The host from which the action described in the ACL rule is allowed or denied.
	Host *string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// Operation which will be allowed or denied. Supported operations are: Read,
	// Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs,
	// DescribeConfigs, IdempotentWrite and All.
	Operation *KafkaUserSpecAuthorizationAclsElemOperation `json:"operation,omitempty" yaml:"operation,omitempty" mapstructure:"operation,omitempty"`

	// List of operations which will be allowed or denied. Supported operations are:
	// Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs,
	// DescribeConfigs, IdempotentWrite and All.
	Operations []KafkaUserSpecAuthorizationAclsElemOperationsElem `json:"operations,omitempty" yaml:"operations,omitempty" mapstructure:"operations,omitempty"`

	// Indicates the resource for which given ACL rule applies.
	Resource KafkaUserSpecAuthorizationAclsElemResource `json:"resource" yaml:"resource" mapstructure:"resource"`

	// The type of the rule. Currently the only supported type is `allow`. ACL rules
	// with type `allow` are used to allow user to execute the specified operations.
	// Default value is `allow`.
	Type *KafkaUserSpecAuthorizationAclsElemType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type KafkaUserSpecAuthorizationAclsElemOperation string

const KafkaUserSpecAuthorizationAclsElemOperationAll KafkaUserSpecAuthorizationAclsElemOperation = "All"
const KafkaUserSpecAuthorizationAclsElemOperationAlter KafkaUserSpecAuthorizationAclsElemOperation = "Alter"
const KafkaUserSpecAuthorizationAclsElemOperationAlterConfigs KafkaUserSpecAuthorizationAclsElemOperation = "AlterConfigs"
const KafkaUserSpecAuthorizationAclsElemOperationClusterAction KafkaUserSpecAuthorizationAclsElemOperation = "ClusterAction"
const KafkaUserSpecAuthorizationAclsElemOperationCreate KafkaUserSpecAuthorizationAclsElemOperation = "Create"
const KafkaUserSpecAuthorizationAclsElemOperationDelete KafkaUserSpecAuthorizationAclsElemOperation = "Delete"
const KafkaUserSpecAuthorizationAclsElemOperationDescribe KafkaUserSpecAuthorizationAclsElemOperation = "Describe"
const KafkaUserSpecAuthorizationAclsElemOperationDescribeConfigs KafkaUserSpecAuthorizationAclsElemOperation = "DescribeConfigs"
const KafkaUserSpecAuthorizationAclsElemOperationIdempotentWrite KafkaUserSpecAuthorizationAclsElemOperation = "IdempotentWrite"
const KafkaUserSpecAuthorizationAclsElemOperationRead KafkaUserSpecAuthorizationAclsElemOperation = "Read"
const KafkaUserSpecAuthorizationAclsElemOperationWrite KafkaUserSpecAuthorizationAclsElemOperation = "Write"

type KafkaUserSpecAuthorizationAclsElemOperationsElem string

const KafkaUserSpecAuthorizationAclsElemOperationsElemAll KafkaUserSpecAuthorizationAclsElemOperationsElem = "All"
const KafkaUserSpecAuthorizationAclsElemOperationsElemAlter KafkaUserSpecAuthorizationAclsElemOperationsElem = "Alter"
const KafkaUserSpecAuthorizationAclsElemOperationsElemAlterConfigs KafkaUserSpecAuthorizationAclsElemOperationsElem = "AlterConfigs"
const KafkaUserSpecAuthorizationAclsElemOperationsElemClusterAction KafkaUserSpecAuthorizationAclsElemOperationsElem = "ClusterAction"
const KafkaUserSpecAuthorizationAclsElemOperationsElemCreate KafkaUserSpecAuthorizationAclsElemOperationsElem = "Create"
const KafkaUserSpecAuthorizationAclsElemOperationsElemDelete KafkaUserSpecAuthorizationAclsElemOperationsElem = "Delete"
const KafkaUserSpecAuthorizationAclsElemOperationsElemDescribe KafkaUserSpecAuthorizationAclsElemOperationsElem = "Describe"
const KafkaUserSpecAuthorizationAclsElemOperationsElemDescribeConfigs KafkaUserSpecAuthorizationAclsElemOperationsElem = "DescribeConfigs"
const KafkaUserSpecAuthorizationAclsElemOperationsElemIdempotentWrite KafkaUserSpecAuthorizationAclsElemOperationsElem = "IdempotentWrite"
const KafkaUserSpecAuthorizationAclsElemOperationsElemRead KafkaUserSpecAuthorizationAclsElemOperationsElem = "Read"
const KafkaUserSpecAuthorizationAclsElemOperationsElemWrite KafkaUserSpecAuthorizationAclsElemOperationsElem = "Write"

// Indicates the resource for which given ACL rule applies.
type KafkaUserSpecAuthorizationAclsElemResource struct {
	// Name of resource for which given ACL rule applies. Can be combined with
	// `patternType` field to use prefix pattern.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Describes the pattern used in the resource field. The supported types are
	// `literal` and `prefix`. With `literal` pattern type, the resource field will be
	// used as a definition of a full name. With `prefix` pattern type, the resource
	// name will be used only as a prefix. Default value is `literal`.
	PatternType *KafkaUserSpecAuthorizationAclsElemResourcePatternType `json:"patternType,omitempty" yaml:"patternType,omitempty" mapstructure:"patternType,omitempty"`

	// Resource type. The available resource types are `topic`, `group`, `cluster`,
	// and `transactionalId`.
	Type KafkaUserSpecAuthorizationAclsElemResourceType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaUserSpecAuthorizationAclsElemResourcePatternType string

const KafkaUserSpecAuthorizationAclsElemResourcePatternTypeLiteral KafkaUserSpecAuthorizationAclsElemResourcePatternType = "literal"
const KafkaUserSpecAuthorizationAclsElemResourcePatternTypePrefix KafkaUserSpecAuthorizationAclsElemResourcePatternType = "prefix"

type KafkaUserSpecAuthorizationAclsElemResourceType string

const KafkaUserSpecAuthorizationAclsElemResourceTypeCluster KafkaUserSpecAuthorizationAclsElemResourceType = "cluster"
const KafkaUserSpecAuthorizationAclsElemResourceTypeGroup KafkaUserSpecAuthorizationAclsElemResourceType = "group"
const KafkaUserSpecAuthorizationAclsElemResourceTypeTopic KafkaUserSpecAuthorizationAclsElemResourceType = "topic"
const KafkaUserSpecAuthorizationAclsElemResourceTypeTransactionalId KafkaUserSpecAuthorizationAclsElemResourceType = "transactionalId"

type KafkaUserSpecAuthorizationAclsElemType string

const KafkaUserSpecAuthorizationAclsElemTypeAllow KafkaUserSpecAuthorizationAclsElemType = "allow"
const KafkaUserSpecAuthorizationAclsElemTypeDeny KafkaUserSpecAuthorizationAclsElemType = "deny"

type KafkaUserSpecAuthorizationType string

const KafkaUserSpecAuthorizationTypeSimple KafkaUserSpecAuthorizationType = "simple"

// Quotas on requests to control the broker resources used by clients. Network
// bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka
// User quotas can be found at
// http://kafka.apache.org/documentation/#design_quotas.
type KafkaUserSpecQuotas struct {
	// A quota on the maximum bytes per-second that each client group can fetch from a
	// broker before the clients in the group are throttled. Defined on a per-broker
	// basis.
	ConsumerByteRate *int32 `json:"consumerByteRate,omitempty" yaml:"consumerByteRate,omitempty" mapstructure:"consumerByteRate,omitempty"`

	// A quota on the rate at which mutations are accepted for the create topics
	// request, the create partitions request and the delete topics request. The rate
	// is accumulated by the number of partitions created or deleted.
	ControllerMutationRate *float64 `json:"controllerMutationRate,omitempty" yaml:"controllerMutationRate,omitempty" mapstructure:"controllerMutationRate,omitempty"`

	// A quota on the maximum bytes per-second that each client group can publish to a
	// broker before the clients in the group are throttled. Defined on a per-broker
	// basis.
	ProducerByteRate *int32 `json:"producerByteRate,omitempty" yaml:"producerByteRate,omitempty" mapstructure:"producerByteRate,omitempty"`

	// A quota on the maximum CPU utilization of each client group as a percentage of
	// network and I/O threads.
	RequestPercentage *int32 `json:"requestPercentage,omitempty" yaml:"requestPercentage,omitempty" mapstructure:"requestPercentage,omitempty"`
}

// Template to specify how Kafka User `Secrets` are generated.
type KafkaUserSpecTemplate struct {
	// Template for KafkaUser resources. The template allows users to specify how the
	// `Secret` with password or TLS certificates is generated.
	Secret *KafkaUserSpecTemplateSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// Template for KafkaUser resources. The template allows users to specify how the
// `Secret` with password or TLS certificates is generated.
type KafkaUserSpecTemplateSecret struct {
	// Metadata applied to the resource.
	Metadata *KafkaUserSpecTemplateSecretMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
type KafkaUserSpecTemplateSecretMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations *apiextensions.JSON `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels *apiextensions.JSON `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations added to the Kubernetes resource.
//type KafkaUserSpecTemplateSecretMetadataAnnotations map[string]interface{}

// Labels added to the Kubernetes resource.
//type KafkaUserSpecTemplateSecretMetadataLabels map[string]interface{}

// The status of the Kafka User.
type KafkaUserStatus struct {
	// List of status conditions.
	Conditions []KafkaUserStatusConditionsElem `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty" yaml:"observedGeneration,omitempty" mapstructure:"observedGeneration,omitempty"`

	// The name of `Secret` where the credentials are stored.
	Secret *string `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`

	// Username.
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

type KafkaUserStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty" yaml:"lastTransitionTime,omitempty" mapstructure:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

var enumValues_KafkaUserSpecAuthenticationType = []interface{}{
	"tls",
	"tls-external",
	"scram-sha-512",
}
var enumValues_KafkaUserSpecAuthorizationAclsElemOperation = []interface{}{
	"Read",
	"Write",
	"Create",
	"Delete",
	"Alter",
	"Describe",
	"ClusterAction",
	"AlterConfigs",
	"DescribeConfigs",
	"IdempotentWrite",
	"All",
}
var enumValues_KafkaUserSpecAuthorizationAclsElemOperationsElem = []interface{}{
	"Read",
	"Write",
	"Create",
	"Delete",
	"Alter",
	"Describe",
	"ClusterAction",
	"AlterConfigs",
	"DescribeConfigs",
	"IdempotentWrite",
	"All",
}
var enumValues_KafkaUserSpecAuthorizationAclsElemResourcePatternType = []interface{}{
	"literal",
	"prefix",
}
var enumValues_KafkaUserSpecAuthorizationAclsElemResourceType = []interface{}{
	"topic",
	"group",
	"cluster",
	"transactionalId",
}
var enumValues_KafkaUserSpecAuthorizationAclsElemType = []interface{}{
	"allow",
	"deny",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationType, v)
	}
	*j = KafkaUserSpecAuthorizationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthenticationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthenticationType, v)
	}
	*j = KafkaUserSpecAuthenticationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorization) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["acls"]; !ok || v == nil {
		return fmt.Errorf("field acls in KafkaUserSpecAuthorization: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in KafkaUserSpecAuthorization: required")
	}
	type Plain KafkaUserSpecAuthorization
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaUserSpecAuthorization(plain)
	return nil
}

var enumValues_KafkaUserSpecAuthorizationType = []interface{}{
	"simple",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["resource"]; !ok || v == nil {
		return fmt.Errorf("field resource in KafkaUserSpecAuthorizationAclsElem: required")
	}
	type Plain KafkaUserSpecAuthorizationAclsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaUserSpecAuthorizationAclsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in KafkaUserSpecAuthentication: required")
	}
	type Plain KafkaUserSpecAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaUserSpecAuthentication(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationAclsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationAclsElemType, v)
	}
	*j = KafkaUserSpecAuthorizationAclsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in KafkaUserSpecAuthorizationAclsElemResource: required")
	}
	type Plain KafkaUserSpecAuthorizationAclsElemResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaUserSpecAuthorizationAclsElemResource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationAclsElemResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationAclsElemResourceType, v)
	}
	*j = KafkaUserSpecAuthorizationAclsElemResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemResourcePatternType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationAclsElemResourcePatternType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationAclsElemResourcePatternType, v)
	}
	*j = KafkaUserSpecAuthorizationAclsElemResourcePatternType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemOperation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationAclsElemOperation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationAclsElemOperation, v)
	}
	*j = KafkaUserSpecAuthorizationAclsElemOperation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthorizationAclsElemOperationsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaUserSpecAuthorizationAclsElemOperationsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaUserSpecAuthorizationAclsElemOperationsElem, v)
	}
	*j = KafkaUserSpecAuthorizationAclsElemOperationsElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaUserSpecAuthenticationPassword) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["valueFrom"]; !ok || v == nil {
		return fmt.Errorf("field valueFrom in KafkaUserSpecAuthenticationPassword: required")
	}
	type Plain KafkaUserSpecAuthenticationPassword
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = KafkaUserSpecAuthenticationPassword(plain)
	return nil
}
