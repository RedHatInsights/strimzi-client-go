// Code generated by schema-generate. DO NOT EDIT.

package v1alpha1

import (
	"bytes"
	"database/sql"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"reflect"
)

func ValueTypeToString(valueType jsoniter.ValueType) string {
	switch valueType {
	case jsoniter.StringValue:
		return "string"
	case jsoniter.NumberValue:
		return "number"
	case jsoniter.NilValue:
		return "nil"
	case jsoniter.BoolValue:
		return "bool"
	case jsoniter.ArrayValue:
		return "array"
	case jsoniter.ObjectValue:
		return "object"
	default:
		return "invalid"
	}
}

type commaTracker struct {
	stream *jsoniter.Stream
	started bool
}

func (t *commaTracker) More() {
	if t.started {
		t.stream.WriteMore()
	} else {
		t.started = true
	}
}

type isEmptyChecker interface {
	IsEmpty() bool
}

// IsEmpty reports whether v is zero struct
// Does not support cycle pointers for performance, so as json
func IsEmpty(v interface{}) bool {
	if i, ok := v.(isEmptyChecker); ok {
		return i.IsEmpty()
	}
	rv := reflect.ValueOf(v)
	return !rv.IsValid() || rv.IsZero()
}

var (
	jsonNullValue = []byte("null")
)

// NewEmptyBool creates a non-empty EmptyBool
func NewEmptyBool(value bool) EmptyBool {
	return EmptyBool{value, true}
}

// EmptyBool is bool or nothing
type EmptyBool struct {
	Bool bool
	Valid bool // Valid is true if Bool is not empty
}

func (t EmptyBool) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyBool) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Bool)
	}
	return []byte("\"\""), nil
}

func (t *EmptyBool) Set(value bool) {
	t.Bool = value
	t.Valid = true
}

func (t *EmptyBool) Unset() {
	t.Bool = false
	t.Valid = false
}

func (t EmptyBool) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteBool(t.Bool)
	} else {
		stream.WriteBool(false)
	}
}

func (t *EmptyBool) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Bool = iter.ReadBool()
	t.Valid = iter.Error == nil
}

func (t *EmptyBool) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Bool); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyFloat64 creates a non-empty EmptyFloat64
func NewEmptyFloat64(value float64) EmptyFloat64 {
	return EmptyFloat64{value, true}
}

// EmptyFloat64 is float64 or nothing
type EmptyFloat64 struct {
	Float64 float64
	Valid bool // Valid is true if Float64 is not empty
}

func (t EmptyFloat64) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyFloat64) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Float64)
	}
	return []byte("\"\""), nil
}

func (t *EmptyFloat64) Set(value float64) {
	t.Float64 = value
	t.Valid = true
}

func (t *EmptyFloat64) Unset() {
	t.Float64 = 0.0
	t.Valid = false
}

func (t EmptyFloat64) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteFloat64(t.Float64)
	} else {
		stream.WriteFloat64(0.0)
	}
}

func (t *EmptyFloat64) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Float64 = iter.ReadFloat64()
	t.Valid = iter.Error == nil
}

func (t *EmptyFloat64) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Float64); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyInt creates a non-empty EmptyInt
func NewEmptyInt(value int) EmptyInt {
	return EmptyInt{value, true}
}

// EmptyInt is int or nothing
type EmptyInt struct {
	Int int
	Valid bool // Valid is true if Int is not empty
}

func (t EmptyInt) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyInt) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.Int)
	}
	return []byte("\"\""), nil
}

func (t *EmptyInt) Set(value int) {
	t.Int = value
	t.Valid = true
}

func (t *EmptyInt) Unset() {
	t.Int = 0
	t.Valid = false
}

func (t EmptyInt) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteInt(t.Int)
	} else {
		stream.WriteInt(0)
	}
}

func (t *EmptyInt) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.Int = iter.ReadInt()
	t.Valid = iter.Error == nil
}

func (t *EmptyInt) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.Int); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// NewEmptyString creates a non-empty EmptyString
func NewEmptyString(value string) EmptyString {
	return EmptyString{value, true}
}

// EmptyString is string or nothing
type EmptyString struct {
	String string
	Valid bool // Valid is true if String is not empty
}

func (t EmptyString) IsEmpty() bool {
	return !t.Valid
}

func (t EmptyString) MarshalJSON() ([]byte, error) {
	if t.Valid {
		return jsoniter.Marshal(t.String)
	}
	return []byte("\"\""), nil
}

func (t *EmptyString) Set(value string) {
	t.String = value
	t.Valid = true
}

func (t *EmptyString) Unset() {
	t.String = ""
	t.Valid = false
}

func (t EmptyString) MarshalJSONStream(stream *jsoniter.Stream) {
	if t.Valid {
		stream.WriteString(t.String)
	} else {
		stream.WriteString("")
	}
}

func (t *EmptyString) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	t.String = iter.ReadString()
	t.Valid = iter.Error == nil
}

func (t *EmptyString) UnmarshalJSON(data []byte) error {
	if err := jsoniter.Unmarshal(data, &t.String); err != nil {
		return err
	}
	t.Valid = true
	return nil
}

// OneOfStringNull is a 'string' or a 'null', and can be emptied
type OneOfStringNull struct {
	currentType jsoniter.ValueType
	stringValue string
}

// NewOneOfStringNull creates a empty OneOfStringNull
func NewOneOfStringNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.InvalidValue, ""}
}

// NewOneOfStringNullString creates a OneOfStringNull of type string
func NewOneOfStringNullString(value string) OneOfStringNull {
	return OneOfStringNull{jsoniter.StringValue, value}
}

// NewOneOfStringNullNull creates a OneOfStringNull of type null
func NewOneOfStringNullNull() OneOfStringNull {
	return OneOfStringNull{jsoniter.NilValue, ""}
}

// IsEmpty returns true if the value is empty
func (value *OneOfStringNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfStringNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsString returns true if the value is a string
func (value *OneOfStringNull) IsString() bool {
	return value.currentType == jsoniter.StringValue
}

// StringValue returns the current value if IsString() is true, "" otherwise
func (value *OneOfStringNull) StringValue() string {
	if value.currentType == jsoniter.StringValue {
		return value.stringValue
	}
	return ""
}

// NullString returns the current value as a sql.NullString
func (value *OneOfStringNull) NullString() sql.NullString {
	return sql.NullString{
		Valid:  value.currentType == jsoniter.StringValue,
		String: value.stringValue,
	}
}

// MarshalJSONStream serializes to a jsoniter Stream
func (value OneOfStringNull) MarshalJSONStream(stream *jsoniter.Stream) {
	if value.currentType == jsoniter.StringValue {
		stream.WriteString(value.stringValue)
	} else {
		stream.WriteNil()
	}
}

// MarshalJSON serialize to json
func (value OneOfStringNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.StringValue:
		return jsoniter.Marshal(value.stringValue)
	}
	return nil, fmt.Errorf(
		"OneOfStringNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

func (value *OneOfStringNull) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	switch t := iter.WhatIsNext(); t {
	case jsoniter.NilValue:
		iter.ReadNil()
		value.currentType = jsoniter.NilValue
	case jsoniter.StringValue:
		value.currentType = jsoniter.StringValue
		value.stringValue = iter.ReadString()
	default:
		iter.ReportError("Read", fmt.Sprintf("unexpected value type: %v", t))
	}
}

// UnmarshalJSON unserialize a OneOfStringNull from json
func (value *OneOfStringNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.stringValue); err != nil {
			return err
		}
		value.currentType = jsoniter.StringValue
	}
	return nil
}

// OneOfNumberNull is a 'string' or a 'null', and can be emptied
type OneOfNumberNull struct {
	currentType jsoniter.ValueType
	numberValue float64
}

// NewOneOfNumberNull creates a empty OneOfNumberNull
func NewOneOfNumberNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.InvalidValue, 0}
}

// NewOneOfNumberNullNumber creates a OneOfNumberNull of type number
func NewOneOfNumberNullNumber(value float64) OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NumberValue, value}
}

// NewOneOfNumberNullNull creates a OneOfNumberNull of type null
func NewOneOfNumberNullNull() OneOfNumberNull {
	return OneOfNumberNull{jsoniter.NilValue, 0}
}

// IsEmpty returns true if the value is empty
func (value *OneOfNumberNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfNumberNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsNumber returns true if the value is a number
func (value *OneOfNumberNull) IsNumber() bool {
	return value.currentType == jsoniter.NumberValue
}

// NumberValue returns the current value if IsNumber() is true, 0 otherwise
func (value *OneOfNumberNull) NumberValue() float64 {
	if value.currentType == jsoniter.NumberValue {
		return value.numberValue
	}
	return 0
}

// MarshalJSON serialize to json
func (value OneOfNumberNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.NumberValue:
		return jsoniter.Marshal(value.numberValue)
	}
	return nil, fmt.Errorf(
		"OneOfNumberNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfNumberNull from json
func (value *OneOfNumberNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.numberValue); err != nil {
			return err
		}
		value.currentType = jsoniter.NumberValue
	}
	return nil
}

// OneOfBoolNull is a 'bool' or a 'null', and can be emptied
type OneOfBoolNull struct {
	currentType jsoniter.ValueType
	boolValue   bool
}

// NewOneOfBoolNull creates a empty OneOfBoolNull
func NewOneOfBoolNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.InvalidValue, false}
}

// NewOneOfBoolNullBool creates a OneOfBoolNull of type number
func NewOneOfBoolNullBool(value bool) OneOfBoolNull {
	return OneOfBoolNull{jsoniter.BoolValue, value}
}

// NewOneOfBoolNullNull creates a OneOfBoolNull of type null
func NewOneOfBoolNullNull() OneOfBoolNull {
	return OneOfBoolNull{jsoniter.NilValue, false}
}

// IsEmpty returns true if the value is empty
func (value *OneOfBoolNull) IsEmpty() bool {
	return value.currentType == jsoniter.InvalidValue
}

// IsNull returns true if the value is 'null'
func (value *OneOfBoolNull) IsNull() bool {
	return value.currentType == jsoniter.NilValue
}

// IsBool returns true if the value is a bool
func (value *OneOfBoolNull) IsBool() bool {
	return value.currentType == jsoniter.BoolValue
}

// BoolValue returns the current value if IsBool() is true, false otherwise
func (value *OneOfBoolNull) BoolValue() bool {
	if value.currentType == jsoniter.BoolValue {
		return value.boolValue
	}
	return false
}

// MarshalJSON serialize to json
func (value OneOfBoolNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case jsoniter.InvalidValue:
		return jsonNullValue, nil
	case jsoniter.NilValue:
		return jsonNullValue, nil
	case jsoniter.BoolValue:
		return jsoniter.Marshal(value.boolValue)
	}
	return nil, fmt.Errorf(
		"OneOfBoolNull unsupported type: %s",
		ValueTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfBoolNull from json
func (value *OneOfBoolNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = jsoniter.NilValue
	} else {
		if err := jsoniter.Unmarshal(data, &value.boolValue); err != nil {
			return err
		}
		value.currentType = jsoniter.BoolValue
	}
	return nil
}

// ConditionsItems 
type ConditionsItems struct {
	// LastTransitionTime Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime string `json:"lastTransitionTime,omitempty"`

	// Message Human-readable message indicating details about the condition's last transition.
	Message string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition (a single word in CamelCase).
	Reason string `json:"reason,omitempty"`

	// Status The status of the condition, either True, False or Unknown.
	Status string `json:"status,omitempty"`

	// Type The unique identifier of a condition, used to distinguish between other conditions in the resource.
	Type string `json:"type,omitempty"`

}

// Config The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
type Config struct {
}

// ConnectorStatus The connector status, as reported by the Kafka Connect REST API.
type ConnectorStatus struct {
}

// KafkaConnector 
type KafkaConnector struct {
	// Spec The specification of the Kafka Connector.
	Spec *Spec `json:"spec,omitempty"`

	// Status The status of the Kafka Connector.
	Status *Status `json:"status,omitempty"`

}

// Spec The specification of the Kafka Connector.
type Spec struct {
	// Class The Class for the Kafka Connector.
	Class string `json:"class,omitempty"`

	// Config The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
	Config *Config `json:"config,omitempty"`

	// Pause Whether the connector should be paused. Defaults to false.
	Pause bool `json:"pause,omitempty"`

	// TasksMax The maximum number of tasks for the Kafka Connector.
	TasksMax int `json:"tasksMax,omitempty"`

}

// Status The status of the Kafka Connector.
type Status struct {
	// Conditions List of status conditions.
	Conditions []*ConditionsItems `json:"conditions,omitempty"`

	// ConnectorStatus The connector status, as reported by the Kafka Connect REST API.
	ConnectorStatus *ConnectorStatus `json:"connectorStatus,omitempty"`

	// ObservedGeneration The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration int `json:"observedGeneration,omitempty"`

	// TasksMax The maximum number of tasks for the Kafka Connector.
	TasksMax int `json:"tasksMax,omitempty"`

}





